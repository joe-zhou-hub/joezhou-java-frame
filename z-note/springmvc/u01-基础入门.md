# 1. springmvc概念入门

**概念：** springmvc是spring框架的控制层技术，核心是前端控制器 `DispatcherServlet`，负责管理和调用其它组件以处理用户的http请求，降低组件间的耦合度：
- 当C端请求符合前端控制器规则时，WEB服务器会将其转交给前端控制器。
- 前端控制器调用映射器 `HandlerMapping`：
    - 根据请求URL找到某个自定义Handler，将其和拦截器（若有）封装成一个执行链并返回。
- 前端控制器调用适配器 `HandlerAdapter`：
    - 执行执行链中拦截器和Handler并返回一个ModelAndView对象。
- 前端控制器调用解析器 `ViewResolver`：
    - 将ModelAndView中的逻辑视图解析为物理视图（页面地址），并返回一个View对象。 
- 前端控制器将View中的数据渲染成静态页面，最终响应给C端。

> z-image/一个核心三个组件.png

# 2. 基础配通

**流程：**
- 添加依赖：spring-webmvc
- 配置前端控制器：在 `web.xml` 中配置springmvc的前端控制器 `DispatcherServlet`
    - `<servlet-name>`：配对名。
    - `<servlet-class>`：核心控制器类的类全名。
    - `<init-param>`：设置在容器初始化的时候，自动加载springmvc的核心配置文件的路径
        - 默认加载位置：`/WEB-INF/配对名的值-servlet.xml`
    - `<url-pattern>` 设置前端控制器的拦截规则：
        - `/`：表示拦截一切，但是不拦截 `*.jsp` 这种后缀类型的url（非静态资源）。
        - `/*`：永远不要这样写。
        - `/user/createUser.action`：表示只拦截 `/user/createUser.action` 请求。
        - `*.action`：表示只拦截以 `.action` 为后缀的请求，注意前面不要加 `/`。
- 配置springmvc核心配置文件：因为springmvc本身就是Spring的子项目，对Spring兼容性很好，所以不需要做很多配置，这里只配置三大组件和一个Controller扫描就可以了。
    - `<mvc:annotation-driven />`：注解驱动负责配置处理器映射器和处理器适配器这两个组件，而视图解析器这个组件，需要我们使用手动配置 `<bean>`，因为要为其配置前后缀，当然也可以不配置。
    - 视图解析器使用springmvc框架默认的 `InternalResourceViewResolver` 这个类。
    - 视图解析器的前后缀配置只作用于响应路径，不作用于请求路径。
- 开发动作类：即控制器类，Handler类：
    - `@RequestMapping` 是用来映射请求（提供对外接口）的，相当于Servlet中的 `@WebServlet` 注解。
    - `@RequestMapping` 中的接口值可以省略 `.action` 后缀，但页面访问该接口时不能省略 `.action` 后缀。
    - `@RequestMapping` 中的接口值可以省略两端的 `/`。
    - 动作类的方法名可以随意一点，对于springmvc来讲不是很重要。
    - 如果方法的返回值是String类型的，则return后面可以直接写返回路径，称为物理视图路径，物理视图路径需要配合视图解析器中配置的前后缀一起使用，如果你没有配置前后缀则必须写全路径。

**配置：** pom.xml
```xml
<!--spring-webmvc-->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-webmvc</artifactId>
    <version>4.1.3.RELEASE</version>
</dependency>
```

**配置：** web.xml
```xml
<servlet>
    <servlet-name>dispatcherServlet</servlet-name>
    <servlet-class>org.springframework.web.servlet.DispatcherServlet</servlet-class>
    <init-param>
        <param-name>contextConfigLocation</param-name>
        <param-value>classpath:springmvc/springmvc.xml</param-value>
    </init-param>
    <load-on-startup>1</load-on-startup>
</servlet>

<servlet-mapping>
    <servlet-name>dispatcherServlet</servlet-name>
    <url-pattern>*.action</url-pattern>
</servlet-mapping>
```

**配置：** springmvc/springmvc.xml
```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:mvc="http://www.springframework.org/schema/mvc"
       xsi:schemaLocation="
           http://www.springframework.org/schema/beans 
           http://www.springframework.org/schema/beans/spring-beans.xsd
           http://www.springframework.org/schema/mvc 
           http://www.springframework.org/schema/mvc/spring-mvc.xsd
           http://www.springframework.org/schema/context 
           http://www.springframework.org/schema/context/spring-context.xsd">

    <!--注解驱动：配置处理器映射器和处理器适配器-->
    <mvc:annotation-driven/>

    <!--配置视图解析器-->
    <bean class="org.springframework.web.servlet.view.InternalResourceViewResolver">
        <property name="prefix" value="/view/"/>
        <property name="suffix" value=".html"/>
    </bean>

    <!--包扫描-->
    <context:component-scan base-package="com.joe.controller"/>

</beans>
```

**源码：**
```java
/**
 * @author JoeZhou
 */
@Controller
public class HelloController {

    @RequestMapping("/hello/test.action")
    public String hello() {
        System.out.println("Hello springmvc!!!");
        return "success";
    }
}
```

> 测试接口：hello/test.action

# 5. 静态资源访问

**概念：** 
- 如果 `web.xml` 中的前端控制器的拦截规则设置成了 `/` 的话会对所有静态资源（html/js/css等，不包括jsp）也进行拦截，然后进行一个核心和三个组件的处理过程，但是静态资源无法经过这些处理，所以最终导致我们无法访问这些静态资源，会报404错误。
- 如果必须要使用 `/`，还想能访问静态资源，可以对静态资源的单独配置，如下：

**配置：** web.xml
```xml
<servlet-mapping>
    <servlet-name>default</servlet-name>
    <url-pattern>*.html</url-pattern>
</servlet-mapping>
<servlet-mapping>
    <servlet-name>default</servlet-name>
    <url-pattern>*.js</url-pattern>
</servlet-mapping>
<servlet-mapping>
    <servlet-name>default</servlet-name>
    <url-pattern>*.css</url-pattern>
</servlet-mapping>
```

# 1. @RequestMapping详解

**概念：** 
- @RequestMapping可以用来映射请求，并提供对外接口。
- 注解式处理器映射器会对类中标记了 `@ResquestMapping` 的方法进行映射，然后匹配对应的方法：
    - 匹配成功：返回 `HandlerMethod` 对象（封装了url对应的方法Method对象）给前端控制器。
    - 匹配失败：则直接404。

## 2. 对外接口值

**概念：** `@RequestMapping`：可以单独写在方法上，表示这个方法使用该映射路径，也可以同时写在类和方法上，此时的映射路径，会将二者拼在一起，如类上是 `/a`，方法上是 `/b`，则最终的映射路径为 `/a/b`。

**源码：**
```java
/**
 * @author JoeZhou
 */
@Controller
@RequestMapping("test")
public class TestController {

    @RequestMapping("test01.action")
    public String test01() {
        System.out.println("test01!!!");
        return "success";
    }
}
```

## 2.1 对外接口数量规则

**概念：** `@RequestMapping` 允许对同一个方法提供多个对外接口：
- `@RequestMapping(value = {"a.action", "b.action"})`
- `@RequestMapping({"a.action", "b.action" })`

**源码：**
```java
@RequestMapping({"test0201.action", "test0202.action"})
public String test02() {
    System.out.println("test02!!!");
    return "success";
}
```

## 2.2 对外接口模糊匹配

**概念：** `@RequestMapping` 可以实现模糊匹配，支持以下符号：
- `?`：匹配一个字符，比如我们的对外接口是 `/a?c/test.action`，此时：
    - `/abc/test.action` 能通过
    - `/abbc/test.action` 不能通过
    - `/ac/test.action` 不能通过
    - `/a/b/b/c/test.action` 不能通过
- `*`：匹配任意字符，比如我们的对外接口是 `/a*c/test.action`，此时：
    - `/abc/test.action` 能通过
    - `/abbc/test.action` 能通过
    - `/ac/test.action` 能通过
    - `/a/b/b/c/test.action` 不能通过
- `**`：匹配多层路径，比如我们的对外接口是 `/a/**/c/test.action`，此时：
    - `/abc/test.action` 能通过
    - `/abbc/test.action` 能通过
    - `/ac/test.action` 能通过
    - `/a/b/b/c/test.action` 能通过

**源码：**
```java
@RequestMapping("/**/test03.action")
public String test03() {
    System.out.println("test03!!!");
    return "success";
}
```

# 3. 请求方式限定

**概念：** REST风格支持四种请求方式，分别是 `GET`（查询）、`POST`（添加）、`PUT`（修改）和 `DELETE`（删除），目前大部分浏览器都支持前两种。

## 3.1 GET和POST请求限定

**概念：** `@RequestMapping` 中的 `method` 属性可以限定请求方式
- `method = RequestMethod.GET`：只接收GET方式提交过来的值，用POST方式传值会报错。
- `method = RequestMethod.POST`：只接收POST方式提交过来的值，用GET方式传值会报错。
- `method = {RequestMethod.GET, RequestMethod.POST})`：两种方式均可接收。

**源码：**
```java
@RequestMapping(value = "/test04.action", method = RequestMethod.GET)
public String test04() {
    System.out.println("test04!!!");
    return "success";
}
```

## 3.2 POST乱码问题

**配置：** web.xml 中添加
```xml
<filter>
    <filter-name>encoding</filter-name>
    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
    <init-param>
        <param-name>encoding</param-name>
        <param-value>UTF-8</param-value>
    </init-param>
</filter>
<filter-mapping>
    <filter-name>encoding</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
```

## 3.3 PUT和DELETE请求限定

**概念：** 大部分浏览器不支持PUT和DELETE请求，但是我们可以利用一个springmvc的一个过滤器 `HiddenHttpMethodFilter` 来进行转换：
1. 在 `web.xml` 中添加 `HiddenHttpMethodFilter` 过滤器，它负责将 `POST` 请求转化为 `DELETE` 或 `PUT` 请求。
2. 在对应表单中添加一个隐藏表单域：`<input type="hidden" name="_method" value="DELETE"/>`
    - `name="_method"` 固定。
    - `value` 值可写 `DELETE` 或 `PUT`。
    - 对应表单的提交方式仍是 `POST`。

**配置：** web.xml
```xml
<!--配置HiddenHttpMethodFilter，可以把POST请求转为DELETE或POST请求-->
<filter>
    <filter-name>HiddenHttpMethodFilter</filter-name>
    <filter-class>org.springframework.web.filter.HiddenHttpMethodFilter</filter-class>
</filter>
     
<filter-mapping>
    <filter-name>HiddenHttpMethodFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
```

## 3.4 Tomcat版本支持

**概念：** tomcat8以上版本默认不允许 `PUT` 请求和 `DELETE` 请求，如有需要，则要 `web.xml` 中进行配置。

**配置：** web.xml 中添加
```xml
<init-param>    
    <param-name>readonly</param-name>   
    <param-value>false</param-value> 
</init-param>
```

# 4. 参数限定

**概念：** `@RequestMapping` 中可以利用 `params` 属性来限定请求进来的参数。
- `params="name"`：必须传给我 `name`，`name` 里是什么值无所谓，否则会报错。
- `params="name=zhaosi"`：必须传给我 `name` 且值必须为 `zhaosi`，否则会报错。
- `params={"name=zhaosi", "age!=18"}`：必须传给我 `name` 且值为 `zhaosi`，如果传给我 `age` 则不能是 `18`，如果不传就算了，否则会报错。
- `params="!name"`：不能传给我 `name`，否则会报错。
**源码：**
```java
@RequestMapping(value = "/test05.action", params = "username")
public String test05(String username, String password) {
    System.out.println(username);
    System.out.println(password);
    return "success";
}
```

# 1. servlet原生对象支持

**概念：** springmvc默认支持的参数类型的 `HttpServletRequest`、`HttpServletResponse` 和 `HttpSession`。

# 2. 依赖

**配置：** pom.xml
```xml
<!--javax.servlet-api-->
<dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>javax.servlet-api</artifactId>
    <version>3.1.0</version>
    <scope>provided</scope>
</dependency>
```

# 3. 动作类

**源码：** ServletController.java
```java
/**
 * @author JoeZhou
 */
@Controller
@RequestMapping("/servlet")
public class ServletController {

    @RequestMapping("/request.action")
    public String request(HttpServletRequest request) {
        System.out.println(request);
        return "success";
    }

    @RequestMapping("/response.action")
    public String response(HttpServletResponse response) {
        System.out.println(response);
        return "success";
    }

    @RequestMapping("/session.action")
    public String session(HttpSession session) {
        System.out.println(session);
        return "success";
    }

    @RequestMapping("/application.action")
    public String application(HttpServletRequest request, HttpSession session) {
        ServletContext application01 = request.getServletContext();
        ServletContext application02 = session.getServletContext();
        System.out.println(application01);
        System.out.println(application02);
        return "success";
    }
}
```
