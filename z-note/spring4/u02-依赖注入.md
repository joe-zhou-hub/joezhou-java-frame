# 1. 常量注入

**概念：** `<bean>` 的子标签 `<property>` 可以对实体类的简单常量进行依赖注入：
- `name/value` 属性可以注入简单类型，如String，Integer等。
- 子标签 `<array>/<value>` 可以注入数组类型。
- 子标签 `<list>/<value>` 可以注入 `List` 类型。
- 子标签 `<set>/<value>` 可以注入 `Set` 类型。
- 子标签 `<map>/<entry>` 可以注入 `Map` 类型。
- 子标签 `<props>/<prop>` 可以注入 `Properties` 类型。

**源码：** /spring4/
- res: `classpath:spring/di/constant.xml`
- src: `c.j.pojo.Emp`
- tst: `c.j.di.DiTest.constant()`

> 注入实际上寻找的是属性的set方法而不是属性本身。

## 3. 注入构造器参数常量

**概念：** 
- `<bean>` 的子标签 `<constructor-arg>` 专门负责对实体类有参构造器参数常量进行注入。
- `<constructor-arg>` 有三个属性：
    - `index`：构造器的角标。
    - `value`：对应参数的值。
    - `type`：对应参数的类型，如果只有一个有参构造器，则可以省略，但如果出现多个构造器重载的情况，则必须用 `type` 来明确指定注入哪一个构造器，否则程序默认注入第一个符合要求的构造器。
- 此方法可以替代工厂模式。

**配置：** spring/di/app-constructor.xml
```xml
<bean id="emp" class="com.joe.pojo.Emp">
    <constructor-arg index="0" value="3" type="double"/>
    <constructor-arg index="1" value="4" type="double"/>
</bean>
```

**源码：** junit测试
```java
@Test
public void diConstructor() {
    String configLocation = "spring/di/app-constructor.xml";
    ClassPathXmlApplicationContext app = new ClassPathXmlApplicationContext(configLocation);
    app.getBean(Emp.class);
    app.close();
}
```

# 2. 实体类注入 

实体类准备

**源码：** EmpDao.java
```java
/**
 * @author JoeZhou
 */
public class EmpDao {
    public void retrieveAll() {
        System.out.println("EmpDao中的查询所有员工的方法...");
    }
}
```

**源码：** EmpService.java
```java
/**
 * @author JoeZhou
 */
@Data
public class EmpService {
    private EmpDao empDao;

    public void retrieveAll() {
        empDao.retrieveAll();
    }
}
```

```!
所有注入的前提是，实体类的属性必须生成对应的 `set()`，建议在生成 `set()` 的同时，也生成 `get()`。
```

## 2. 注入实体类

**概念：** 正常业务流程中，业务层 `service` 中需要埋一个数据层 `dao` 的实例，所以可以将 `dao` 的实例当成 `service` 的一个属性，然后利用 `<property>` 标签来进行注入。

### 2.1 外部注入实体类

**配置：** spring/di/app-emp-1.xml
```xml
<bean id="empDao" class="com.joe.dao.EmpDao"/>

<!--在实例化EmpService同时注入Dao-->
<bean class="com.joe.service.EmpService">

    <!--使用ref来引用另一个<bean>-->
    <property name="empDao" ref="empDao" />
</bean>
```

```!
<property>中的name属性是EmpService中埋的EmpDao实例的属性变量名，但是其本质上是跟set()/get()方法相关，不和属性变量名相关。
```

**源码：** junit测试
```java
@Test
public void diEmpDao01() {
    String configLocation = "spring/di/app-emp-1.xml";
    ClassPathXmlApplicationContext app = new ClassPathXmlApplicationContext(configLocation);
    EmpService empService = app.getBean(EmpService.class);
    empService.retrieveAll();
    app.close();
}
```

### 2.2 内部注入实体类

**配置：** spring/di/app-emp-2.xml
```xml
<bean class="com.joe.service.EmpService">
    <property name="empDao">
        <bean class="com.joe.dao.EmpDao"/>
    </property>
</bean>
```

**源码：** junit测试
```java
@Test
public void diEmpDao02() {
    String configLocation = "spring/di/app-emp-2.xml";
    ClassPathXmlApplicationContext app = new ClassPathXmlApplicationContext(configLocation);
    EmpService empService = app.getBean(EmpService.class);
    empService.retrieveAll();
    app.close();
}
```

> 思考：接口和实现类的模式，应该如何注入？

# 3. 相关注解

为何使用注解

**概念：** 使用xml配置文件进行IOC和DI的设置，可读性强，代码灵活度高，而使用注解的方式，虽然可读性低，但是会让代码变得更加简单。

## 2. 注解依赖

**概念：** 使用注解开发需要引入两个jar包，或者使用对应的两个依赖。
- `spring-aop-4.3.14.jar`
- `spring-context-4.3.14.jar`

## 3. 注解底层驱动

**概念：** 使用注解开发需要事先在spring容器中声明下面对应的 `<bean>`

想使用的注解 | 需要驱动的类
-|-
`@Autowired` | `AutowiredAnnotationBeanPostProcessor`
`@Required` | `RequiredAnnotationBeanPostProcessor`
`@Resource`<br/>`@PreDestroy`<br/>`@PostConstruct` |  `CommonAnnotationBeanPostProcessor`
`@PersistenceContext` |  `PersistenceAnnotationBeanPostProcessor`

**配置：**
```xml
<bean class="org.springframework.beans.factory.
    annotation.AutowiredAnnotationBeanPostProcessor"/>
<bean class="org.springframework.beans.factory.
    annotation.RequiredAnnotationBeanPostProcessor"/>
<bean class="org.springframework.beans.factory.
    annotation.CommonAnnotationBeanPostProcessor"/>
<bean class="org.springframework.beans.factory.
    annotation.PersistenceAnnotationBeanPostProcessor"/>
```

## 4. 注解简洁驱动

**概念：** 
- 更优雅的注解开启方式是，使用 `<context:annotation-config/>` 隐式地向spring容器注册上面的这4个 `BeanPostProcessor` 。
- 如果spring容器不识别 `<context>` 标签，可以在头部添加约束信息如下：

**配置：**
```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xsi:schemaLocation="
       http://www.springframework.org/schema/beans
       http://www.springframework.org/schema/beans/spring-beans.xsd
       http://www.springframework.org/schema/context
       http://www.springframework.org/schema/context/spring-context.xsd">
       
    <context:annotation-config/>
</beans>
```

> 后面我们会使用到包扫描，包含了自动注入上述4个Processor的功能，因此当使用包扫描后，即可将 `<context:annotation-config/>` 省去。


# 4. @Resource注解

**概念：** `@Resource` 是J2EE的注解，与spring无关，将 `@Resource` 直接作用在属性上，可以帮我们自动注入属性，自动分析关系。
- 使用 `@Resource`，则不再需要实体类中提供对应的 `set()/ get()`，但继续提供也无妨。
- 使用 `@Resource`，则不再需要在xml文件中指定类和类的关系。

## 2. @Resource匹配流程

**概念：**
- `@Resource` 写法：容器初始化时，用 `@Resource` 所在的属性名和容器中的所有 `<bean>` 的 `id` 进行匹配：
    - `id` 匹配成功：new对应的实体类。
    - `id` 匹配失败，再用注解所在的属性类型的类全名和容器中的所有 `<bean>` 的 `class` 进行匹配。
        - `class` 匹配成功：new对应的实体类，注意类与接口的关系也算匹配成功。
        - `class` 匹配失败：报错，注意匹配到多个也算失败。
- `@Resource(name="abc")` 写法：容器初始化时，用 `abc` 去和容器中的所有 `<bean>` 的 `id` 进行匹配。
    - `id` 匹配成功：new对应的实体类。
    - `id` 匹配失败：直接报错。

**源码：** DeptDao.java
```java
/**
 * @author JoeZhou
 */
public class DeptDao {
    public void retrieveAll() {
        System.out.println("DeptDao中的查询所有部门的方法...");
    }
}
```

**源码：** DeptService.java：
```java
/**
 * @author JoeZhou
 */
public class DeptService {

    @Resource
    private DeptDao deptDao;

    public void retrieveAll() {
        deptDao.retrieveAll();
    }
}
```

**配置：** spring/di/app-dept.xml
```xml
<context:annotation-config/>
<!--因使用了@Resource，故无需指定service和dao之间的依赖关系-->
<bean id="deptDao" class="com.joe.dao.DeptDao"></bean>
<bean class="com.joe.service.DeptService"></bean>
```

**源码：** junit测试
```java
@Test
public void diDeptDao() {
    String configLocation = "spring/di/app-dept.xml";
    ClassPathXmlApplicationContext app = new ClassPathXmlApplicationContext(configLocation);
    app.getBean(DeptService.class).retrieveAll();
    app.close();
}
```

# 5. @Autowired注解

**概念：** `@Autowired` 是spring的一个注解，可以对成员属性、属性的 `set()` 上和构造函数上进行标注，来完成自动装配的工作。

## 2. @Autowired匹配流程

**概念：**
- 优先使用 `@Autowired` 所在的属性类型的类全名和容器中的所有 `<bean>` 的 `class` 进行匹配。
    - `class` 匹配成功：new对应的实体类，注意类与接口的关系也算匹配成功。
    - `class` 匹配失败：用注解所在的属性名和容器中的所有 `<bean>` 的 `id` 进行匹配（4.3版本以上支持）。
        - `id` 匹配成功：new对应的实体类。
        - `id` 匹配失败，报错。 
- 如果非要按照 `id` 来匹配，建议配合 `@Qualifier("abc")` 效果更好。

**源码：** CarDao.java
```java
/**
 * @author JoeZhou
 */
public class CarDao {
    public void move() {
        System.out.println("CarDao中的方法...");
    }
}
```

**源码：** CarService.java
```java
/**
 * @author JoeZhou
 */
public class CarService {

    private CarDao carDao;

    @Autowired
    public CarService(CarDao carDao){
        this.carDao = carDao;
    }

    public void move() {
        carDao.move();
    }
}
```

**配置：** spring/di/app-car.xml
```xml
<context:annotation-config/>

<!--因使用了@Resource，故无需指定service和dao之间的依赖关系-->
<bean id="carDao" class="com.joe.dao.CarDao"/>
<bean class="com.joe.service.CarService"/>
```

**源码：** junit测试
```java
@Test
public void diDeptDao() {
    String configLocation = "spring/di/app-car.xml";
    ClassPathXmlApplicationContext app = new ClassPathXmlApplicationContext(configLocation);
    app.getBean(CarService.class).move();
    app.close();
}
```

# 6. 四大注解

**概念：** 
- 为了减轻大spring配置文件中的 `<bean>` 的数量负担，我们可以使用四大注解来替代某些 `<bean>` 的配置。
- 能被扫描到的类必须拥有 `@Component` 标识，`@Controller`、`@Service` 和 `@Repository` 都是  `@Component` 的上层语义化注解。
- 如果是接口实现类的关系，请将注解放在实现类上，因为接口new不了。
-  `@Component` 及其上层三个注解都支持设置 `value` 值来绑定 `<bean>` 的 `id`，如果不设置 `value` 则默认为该类名的首字母小写形式，但如果你的类名是像 `MVCService` 之类的，前几个字母都是大写字母的形式的时候，则 `<bean>` 的 `id` 值仍然是 `MVCService`，首字母不会变成小写。

能被扫描到的注解 | 描述
-|-
`@Controller` | 表示所在类是控制层，会被容器扫描到，无需为其配置 `<bean>`。
`@Service` | 表示所在类是业务层，会被容器扫描到，无需为其配置 `<bean>`。
`@Repository` | 表示所在类是数据层，会被容器扫描到，无需为其配置 `<bean>`。
`@Component` | 表示所在类会被容器扫描到，无需为其配置 `<bean>`。

## 2. 包扫描

**概念：** 使用注解扫描器来指定扫描范围包及其子包，此时可不用再驱动注解。

**源码：** DogDao.java
```java
/**
 * @author JoeZhou
 */
@Repository
public class DogDao {
    public void talk() {
        System.out.println("wang wang!");
    }
}
```

**源码：** DogService.java
```java
/**
 * @author JoeZhou
 */
@Service
public class DogService {
    private DogDao dogDao;

    @Autowired
    public DogService(DogDao dogDao) {
        this.dogDao = dogDao;
    }

    public void talk() {
        dogDao.talk();
    }
}
```

**配置：** spring/di/app-dog.xml
```xml
<context:component-scan base-package="com.joe.dao"/>
<context:component-scan base-package="com.joe.service"/>
```

**源码：** junit测试
```java
@Test
public void diDogDao() {
    String configLocation = "spring/di/app-dog.xml";
    ClassPathXmlApplicationContext app = new ClassPathXmlApplicationContext(configLocation);
    DogService dogService = app.getBean(DogService.class);
    dogService.talk();
    app.close();
}
```
