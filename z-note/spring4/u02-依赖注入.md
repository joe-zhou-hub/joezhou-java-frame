# 1. 常量属性DI

**概念：** `<bean>` 的子标签 `<property>` 用于常量属性注入，简单类型如String，Integer等直接使用 `name` 和 `value` 属性进行注入，复杂类型使用其子孙标签配合如下：
- `<array>` + `<value>` 用于注入数组类型属性。
- `<list>` + `<value>` 用于注入 `List` 类型属性。
- `<set>` + `<value>` 用于注入 `Set` 类型属性。
- `<map>` + `<entry>` 用于注入 `Map` 类型属性。
- `<props>` + `<prop>` 用于注入 `Properties` 类型属性。

**源码：** /spring4/
- res: `classpath:spring/di/constant-field.xml`
- src: `c.j.pojo.Emp`
- tst: `c.j.di.DiTest.constantField()`

> 依赖注入时，spring容器寻找的是属性对应的 `set()` 而非属性本身。

# 2. 构造形参DI

**概念：** `<bean>` 的子标签 `<constructor-arg>` 用于构造形参注入，可以替代工厂模式：
- `index`：形参角标，从0开始。
- `value`：对应角标的变量值。
- `type`：对应角标的变量类型，当bean中仅有一个有参构造时可以省略。

**源码：** /spring4/
- res: `classpath:spring/di/constructor.xml`
- src: `c.j.pojo.Manager`
- tst: `c.j.di.DiTest.constructor()`

# 3. 实体类DI

**概念：** 在Service层中注入Dao层的实例有两种方式：
- 外部注入：使用 `<property>` 的 `ref` 引用Dao的 `<bean>` 的id。
- 内部注入：使用 `<property>` 直接包裹Dao的 `<bean>`。

**源码：** /spring4/
- res: `classpath:spring/di/bean-outer.xml`
- res: `classpath:spring/di/bean-inner.xml`
- src: `c.j.dao.CarDao`
- src: `c.j.service.CarService`
- tst: `c.j.di.DiTest.beanOuter()`
- tst: `c.j.di.DiTest.beanInner()`

# 4. 注解方式DI

**概念：** 注解可以替代xml配置进行IOC和DI的设置，让代码变得更加简单。
- 注解依赖：使用注解开发需要引入两个依赖：
    - `spring-aop-4.3.14.jar`
    - `spring-context-4.3.14.jar`
- 注解驱动：使用注解开发需要事先在spring容器中声明下面对应的 `org.springframework.beans.factory.annotation` 包中的 `<bean>`：
    - `@Autowired` 需要 `AutowiredAnnotationBeanPostProcessor` 驱动。
    - `@Required` 需要 `RequiredAnnotationBeanPostProcessor` 驱动。
    - `@Resource` 需要 `CommonAnnotationBeanPostProcessor` 驱动。
    - `@PreDestroy` 需要 `CommonAnnotationBeanPostProcessor` 驱动。
    - `@PostConstruct` 需要 `CommonAnnotationBeanPostProcessor` 驱动。
    - `@PersistenceContext` 需要 `PersistenceAnnotationBeanPostProcessor` 驱动。
- 注解简洁驱动
    - 更优雅的注解开启方式是，使用 `<context:annotation-config/>` 隐式地向spring容器注册上面的这4个 `BeanPostProcessor` 。
    - 如果spring容器不识别 `<context>` 标签，可以在头部添加约束信息如下：

**配置：**
```xml
<beans xmlns="http://www.springframework.org/schema/beans"
      xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
      xmlns:context="http://www.springframework.org/schema/context"
      xsi:schemaLocation="
      http://www.springframework.org/schema/beans
      http://www.springframework.org/schema/beans/spring-beans.xsd
      http://www.springframework.org/schema/context
      http://www.springframework.org/schema/context/spring-context.xsd">
      
   <context:annotation-config/>
</beans>
``` 

> 后面我们会使用到包扫描，包含了自动注入上述4个Processor的功能，因此当使用包扫描后，即可将 `<context:annotation-config/>` 省去。
    
**配置：**
```xml
<bean class="org.springframework.beans.factory.
    annotation.AutowiredAnnotationBeanPostProcessor"/>
<bean class="org.springframework.beans.factory.
    annotation.RequiredAnnotationBeanPostProcessor"/>
<bean class="org.springframework.beans.factory.
    annotation.CommonAnnotationBeanPostProcessor"/>
<bean class="org.springframework.beans.factory.
    annotation.PersistenceAnnotationBeanPostProcessor"/>
```

## 4.1 @Resource注解

**概念：** `@Resource` 是J2EE的注解，与spring无关，将 `@Resource` 直接作用在属性上，可以帮我们自动注入属性，自动分析关系。
- 使用 `@Resource`，则不再需要实体类中提供对应的 `set()/ get()`，但继续提供也无妨。
- 使用 `@Resource`，则不再需要在xml文件中指定类和类的关系。

@Resource匹配流程
**概念：**
- `@Resource` 写法：容器初始化时，用 `@Resource` 所在的属性名和容器中的所有 `<bean>` 的 `id` 进行匹配：
    - `id` 匹配成功：new对应的实体类。
    - `id` 匹配失败，再用注解所在的属性类型的类全名和容器中的所有 `<bean>` 的 `class` 进行匹配。
        - `class` 匹配成功：new对应的实体类，注意类与接口的关系也算匹配成功。
        - `class` 匹配失败：报错，注意匹配到多个也算失败。
- `@Resource(name="abc")` 写法：容器初始化时，用 `abc` 去和容器中的所有 `<bean>` 的 `id` 进行匹配。
    - `id` 匹配成功：new对应的实体类。
    - `id` 匹配失败：直接报错。

**源码：** DeptDao.java
```java
/**
 * @author JoeZhou
 */
public class DeptDao {
    public void retrieveAll() {
        System.out.println("DeptDao中的查询所有部门的方法...");
    }
}
```

**源码：** DeptService.java：
```java
/**
 * @author JoeZhou
 */
public class DeptService {

    @Resource
    private DeptDao deptDao;

    public void retrieveAll() {
        deptDao.retrieveAll();
    }
}
```

**配置：** spring/di/app-dept.xml
```xml
<context:annotation-config/>
<!--因使用了@Resource，故无需指定service和dao之间的依赖关系-->
<bean id="deptDao" class="com.joe.dao.DeptDao"></bean>
<bean class="com.joe.service.DeptService"></bean>
```

**源码：** junit测试
```java
@Test
public void diDeptDao() {
    String configLocation = "spring/di/app-dept.xml";
    ClassPathXmlApplicationContext app = new ClassPathXmlApplicationContext(configLocation);
    app.getBean(DeptService.class).retrieveAll();
    app.close();
}
```

## 4.2 @Autowired注解

**概念：** `@Autowired` 是spring的一个注解，可以对成员属性、属性的 `set()` 上和构造函数上进行标注，来完成自动装配的工作。

@Autowired匹配流程
**概念：**
- 优先使用 `@Autowired` 所在的属性类型的类全名和容器中的所有 `<bean>` 的 `class` 进行匹配。
    - `class` 匹配成功：new对应的实体类，注意类与接口的关系也算匹配成功。
    - `class` 匹配失败：用注解所在的属性名和容器中的所有 `<bean>` 的 `id` 进行匹配（4.3版本以上支持）。
        - `id` 匹配成功：new对应的实体类。
        - `id` 匹配失败，报错。 
- 如果非要按照 `id` 来匹配，建议配合 `@Qualifier("abc")` 效果更好。

**源码：** CarDao.java
```java
/**
 * @author JoeZhou
 */
public class CarDao {
    public void move() {
        System.out.println("CarDao中的方法...");
    }
}
```

**源码：** CarService.java
```java
/**
 * @author JoeZhou
 */
public class CarService {

    private CarDao carDao;

    @Autowired
    public CarService(CarDao carDao){
        this.carDao = carDao;
    }

    public void move() {
        carDao.move();
    }
}
```

**配置：** spring/di/app-car.xml
```xml
<context:annotation-config/>

<!--因使用了@Resource，故无需指定service和dao之间的依赖关系-->
<bean id="carDao" class="com.joe.dao.CarDao"/>
<bean class="com.joe.service.CarService"/>
```

**源码：** junit测试
```java
@Test
public void diDeptDao() {
    String configLocation = "spring/di/app-car.xml";
    ClassPathXmlApplicationContext app = new ClassPathXmlApplicationContext(configLocation);
    app.getBean(CarService.class).move();
    app.close();
}
```

## 4.3 四大注解

**概念：** 
- 为了减轻大spring配置文件中的 `<bean>` 的数量负担，我们可以使用四大注解来替代某些 `<bean>` 的配置。
- 能被扫描到的类必须拥有 `@Component` 标识，`@Controller`、`@Service` 和 `@Repository` 都是  `@Component` 的上层语义化注解。
- 如果是接口实现类的关系，请将注解放在实现类上，因为接口new不了。
-  `@Component` 及其上层三个注解都支持设置 `value` 值来绑定 `<bean>` 的 `id`，如果不设置 `value` 则默认为该类名的首字母小写形式，但如果你的类名是像 `MVCService` 之类的，前几个字母都是大写字母的形式的时候，则 `<bean>` 的 `id` 值仍然是 `MVCService`，首字母不会变成小写。

能被扫描到的注解 | 描述
-|-
`@Controller` | 表示所在类是控制层，会被容器扫描到，无需为其配置 `<bean>`。
`@Service` | 表示所在类是业务层，会被容器扫描到，无需为其配置 `<bean>`。
`@Repository` | 表示所在类是数据层，会被容器扫描到，无需为其配置 `<bean>`。
`@Component` | 表示所在类会被容器扫描到，无需为其配置 `<bean>`。

## 4.4 包扫描

**概念：** 使用注解扫描器来指定扫描范围包及其子包，此时可不用再驱动注解。

**源码：** DogDao.java
```java
/**
 * @author JoeZhou
 */
@Repository
public class DogDao {
    public void talk() {
        System.out.println("wang wang!");
    }
}
```

**源码：** DogService.java
```java
/**
 * @author JoeZhou
 */
@Service
public class DogService {
    private DogDao dogDao;

    @Autowired
    public DogService(DogDao dogDao) {
        this.dogDao = dogDao;
    }

    public void talk() {
        dogDao.talk();
    }
}
```

**配置：** spring/di/app-dog.xml
```xml
<context:component-scan base-package="com.joe.dao"/>
<context:component-scan base-package="com.joe.service"/>
```

**源码：** junit测试
```java
@Test
public void diDogDao() {
    String configLocation = "spring/di/app-dog.xml";
    ClassPathXmlApplicationContext app = new ClassPathXmlApplicationContext(configLocation);
    DogService dogService = app.getBean(DogService.class);
    dogService.talk();
    app.close();
}
```
