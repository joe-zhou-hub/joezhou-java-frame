# 1. 概念入门

**概念：** Spring是2003年兴起的一个轻量级的JAVA开源框架，核心特性是控制反转和面向切面编程：
- 历史发展：
    - Spring1.x时代只能使用xml配置bean，随着项目扩大，bean和xml配置的数量不断增多，二者之间切换频繁。
    - Spring2.x时代支持使用JDK5带来的注解配置bean，减少了xml配置代码，简化项目。
    - Spring3.x时代开始支持使用纯java代码配置bean，SpringBoot推荐此种方案。
    - 总结：基本配置如数据源建议使用可读性更高的XML配置，开发相关如Service注入Dao等建议使用更简单的注解配置。
- 控制反转IOC：Inversion of Control，就是将实例化过程和实例生命周期管理都交给spring容器，以解决手动new实例时，侵入性和耦合度双高的问题。
- 依赖注入DI：depend injection，将IOC产生的实例注入到bean中的过程。
- 面向切面AOP：Aspect Oriented Programming，就是通过预编译的方式在运行期使用动态代理实现的一种技术，主要作用于控制事务的传播，如一套下单事务中：
    - `orderDao.insert(order);`：添加订单后，事务应该向下传播。
    - `detailDao.insert(detail);`：添加明细后，事务不该向下传播。
    - `logDao.insert(log);`：无论添加成功该是失败，都应该记录日志。
- 官方下载：[Spring官方下载地址](https://repo.spring.io/release/org/springframework/spring)，建议下载 `4.3.14.RELEASE-dist` 版本：
    - Framework5.x 支持 JDK8+
    - Framework4.x 支持 JDK6+
    - Framework3.x 支持 JDK5+

> spring产品图解

# 2. 基础配通

**流程：**
- 引入最简依赖：
    - spring-core：核心包，被很多其他spring模块引用。
    - spring-beans：管理java类的包。
    - spring-context：Spring上下文包。
    - spring-context-support：Spring上下文包拓展包。
    - spring-expression：SpEL表达式语言包。
- 在classpath下开发核心配置文件：`app-start.xml`：
    - 配置文件就是spring容器，相当于一个鱼缸。
    - 头信息在 `7.2.1 Configuration metadata`
- 开发实体类：`Student.java`：
    - 埋一个 `name` 属性并配置set()/get()。
- 在spring容器中管理实体类：使用 `<bean></bean>` 来关联实体类，每个 `<bean>` 都相当于鱼缸中的一条鱼：
    - `<bean>` 中使用 `id` 属性设置唯一标识，可以随意命名。
    - `<bean>` 中使用 `class` 属性关联Student实体类的类全名。
- 测试：
    - `new ClassPathXmlApplicationContext()`：指定核心配置文件位置以造鱼缸。
    - `getBean()`：通过id的方式捞出对应Student实例类的那条鱼。
    - `setName()/getName()`：使用这条鱼。  
    - `close()`：砸鱼缸以释放资源。

**源码：** /spring4/
- res: `pom.xml`
- res: `spring/start/app-start.xml`
- src: `c.j.pojo.Student`
- tst: `c.j.start.AppStartTest.start()`

# 3. 同时读取多份配置

**概念：** 同时实例化多个容器有两种方式：
- 在 `ClassPathXmlApplicationContext` 构造器中使用核心配置文件字符串数组。
- 在一个核心配置文件中使用 `<import resource="">` 引入另一个核心配置文件。

**源码：** /spring4/
- res: `spring/start/app-multiple-a/b/c/d.xml`
- src: `c.j.pojo.Student`
- tst: `c.j.start.AppStartTest.multipleByConstructor()/multipleByImport()`

# 4. 获取bean的方式

**概念：** 通过 `id`、通过 `name` 和通过 `类的字节码` 都可以获取到bean。

## 2.1 通过id获取

**概念：** 使用 `id` 来获取bean是相对而言比较规范的一种方式。

**配置：** spring/start/app-by-id.xml
```xml
<bean id="studentId" class="com.joe.pojo.Student" />
```

**源码：** junit测试。
```java
@Test
public void getBeanById() {
    String configLocation = "spring/start/app-by-id.xml";
    ClassPathXmlApplicationContext app = new ClassPathXmlApplicationContext(configLocation);
    Student student = (Student) app.getBean("studentId");
    student.getInfo();
    app.close();
}
```

## 2.2 通过name获取

**概念：** 
- `name` 可以重复，但是相同 `name` 的 `<bean>` 会发生覆盖。
- 同时存在 `id` 和 `name`，会优先使用 `id`，此时 `name` 将会被作为别名，二者皆可通过 `getBean()` 获取。

**配置：** spring/start/app-by-name.xml
```xml
<bean name="studentName" class="com.joe.pojo.Student" />
```

**源码：** junit测试。
```java
@Test
public void getBeanByName() {
    String configLocation = "spring/start/app-by-name.xml";
    ClassPathXmlApplicationContext app = new ClassPathXmlApplicationContext(configLocation);
    Student student = (Student) app.getBean("studentName");
    student.getInfo();
    app.close();
}
```

## 2.3 通过class获取

**概念：** 直接使用类的字节码来获取bean的方式，可以省略掉强转这一步骤。

**配置：** spring/start/app-by-class.xml
```xml
<bean class="com.joe.pojo.Student" />
```

**源码：** junit测试。
```java
@Test
public void getBeanByClass() {
    String configLocation = "spring/start/app-by-class.xml";
    ClassPathXmlApplicationContext app = new ClassPathXmlApplicationContext(configLocation);
    Student student = app.getBean(Student.class);
    student.getInfo();
    app.close();
}
```

# 5. 文件系统容器

**概念：** 如果你的核心配置文件不在 `classpath` 下，而是在 `webapp` 下，需要使用 `FileSystemXmlApplicationContext` 替换 `ClassPathXmlApplicationContext`。

**配置：** 在 `webapp` 下新建 `app-file-system.xml`：
```xml
<bean class="com.joe.pojo.Student" />
```

**源码：** junit测试。
```java
@Test
public void fileSystem() {
    String configLocation = "src/main/webapp/app-file-system.xml";
    FileSystemXmlApplicationContext app = new FileSystemXmlApplicationContext(configLocation);
    Student student = app.getBean(Student.class);
    student.getInfo();
    app.close();
}
```
