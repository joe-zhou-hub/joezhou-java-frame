# 1. jdk动态代理

**概念：** jdk动态代理的客户（聘请代理的对象）必须是某接口的实现类：
- 开发客户类，并且封装CRUD四个方法。
- 开发jdk代理公司类：实现 `InvocationHandler` 接口并重写 `invoke()` 工作清单：
    - param1：代理对象。
    - param2：代理方法的Method对象。
    - param3：代理方法的形参。
    - return：代理方法的返回值，若是 `void`，就返回 `null`。
- 开发聘用代理方法：核心代码为 `Proxy.newProxyInstance()`：
    - param1：客户的类加载器。
    - param2：客户的接口们。
    - param3：代理应该调用哪个类中的工作清单方法。
    - return：返回客户的代理对象。
- 设计工作清单内容：
    - 模拟业务方法前的工作，比如鉴权。
    - 利用反射执行业务方法。
    - 模拟业务方法后的工作，比如打印日志。
- 测试聘用代理的方法：
    - 创建客户并为客户聘用代理。
    - 将代理类型强转为客户接口类型，否则无法调用业务方法。

> z-res: jdk动态代理小说.md

**源码：** /spring4/
- src: `c.j.aop.proxy.JdkProxyCompany`
- src: `c.j.aop.proxy.UserService`
- src: `c.j.aop.proxy.UserServiceImpl`
- tst: `c.j.aop.JdkProxyTest.jdkProxy()`

# 2. cglib动态代理

**概念：** cglib是spring提供的动态代理，可以对任何非 `final` 的类进行代理：
- 开发客户类，并且封装CRUD四个方法。
- 开发cglib代理公司类：实现 `MethodInterceptor` 接口并重写 `intercept()` 工作清单：
    - param1：代理对象。
    - param2：代理方法的Method对象。
    - param3：代理方法的形参。
    - param4：方法的代理对象。
    - return：代理方法的返回值，若是 `void`，就返回 `null`。
- 开发聘用代理方法：核心代码为 `new Enhancer().create()`：
    - 创建之前需要设置客户的父类。
    - 创建之前需要设置回调对象，即代理应该调用哪个类中的工作清单方法。
- 设计工作清单内容：
    - 模拟业务方法前的工作，比如鉴权。
    - 利用反射执行业务方法。
    - 模拟业务方法后的工作，比如打印日志。
- 测试聘用代理的方法：
    - 创建客户并为客户聘用代理。
    - 将代理类型强转为客户接口类型，否则无法调用业务方法。

**源码：** /spring4/
- src: `c.j.aop.proxy.CglibProxyCompany`
- src: `c.j.aop.proxy.BearServiceImpl`
- tst: `c.j.aop.CglibProxyTest.cglibProxy()`

# 3. AOP概念

**概念：** Aspect Oriented Programming，面向切面编程，是OOP的延续，它通过预编译的方式在运行期，使用动态代理来实现业务代码和切面代码的逻辑分离，降低耦合度，从而提高程序的重用性：
- OOP技术名词：现在我想让A类中的100个方法，在被调用之前判断一下用户是否已经登录，在被调用之后打印日志，于是想到聘用代理，那么：
    - A类就是客户 `Target`，因为接受我们代理的就是它。
    - A类里的100个方法，就是100个连接点 `JoinPoint`，当然如果某个方法设置了不使用代理，那它就不被称为连接点。
    - 这100个连接点，可以组成一个切点 `Pointcut`，切点就是一个范围。
    - 方法调用之前的内容，叫做前置通知 `Advice`。
    - 方法调用之后的内容，叫做后置通知 `Adivce`。
    - 方法调用的时候出了异常，触发异常通知 `Advice`。
    - 方法返回结果之后执行的内容，叫做返回后通知 `Advice`。
    - 一堆切点和一堆通知组成一个切面类 `Aspect`。
    - 以上整个过程叫做织入 `Weave`。
- PE表达式：Pointcut Expression，作用于切点方法上的 `@Pointcut()` 中，用于指定那些方法需要使用AOP操作：
    - 模板：`execution([修饰符] 返回类型 [包名].[类名].方法名(方法参数) [异常])`
    - 修饰符：如 `public`，`public/private` 等。
    - 返回值：如 `*`，`void`，`void/java.lang.String`，`!void` 等。
    - 包名：如 `c.j.service`，`c.j.service..`（子孙包），`c.j.*`，`c.*.service` 等。
    - 类名：如 `HelloWorld`，`*World`，`Hello*` 等。
    - 方法名：如 `InsertUser`，`*User`，`Insert*` 等。
    - 方法参数：如 `..`（任意数量），`*`（一个），`int,..`（第一个参数为int，后面任意）等

> 除PE表达式外，还可以用args()、@args()、this()、target()、@target、within()、@within()、@annotation 等进行范围描述。

## 3.1 AOP准备

- 添加 `spring-aspects` 切面依赖。
- 开发客户类
- 开发切面类
    - 切面类必须由 `@Aspect` 和 `@Component` 组合修饰，声明此类为切面类且可以被spring容器扫描并管理。
    - 切面类中需要包括切点方法，配合 `@Pointcut("execution()")` 来指定切点范围，即哪些方法需要被执行AOP。
    - 切点方法名随意，一个类中可以有多个切点方法，方法名仅仅用来区别它们，但切点方法必须是空方法。

- res: `pom.xml`

客户类
```java
/**
 * @author JoeZhou
 */
@Service
public class CustomerService {}
```

切面类
```java
/**
 * @author JoeZhou
 */
@Aspect
@Component
public class CustomerAspectByAnn {

    @Pointcut("execution(public * com.joe.service..*.*(..))")
    public void myPointCut() {}
}
```

## 4. XML配置

**概念：** AOP相关的配置需要引入AOP的xsd约束。

**配置：** spring/aop/app-customer-ann.xml
```xml
<!-- 包扫描只能扫@Component注解 -->
<context:component-scan base-package="com.joe.aop.aspect"/>

<!-- 负责扫@Aspect注解 -->
<aop:aspectj-autoproxy/>
```
