# 1. jdk动态代理

**概念：** jdk动态代理的客户（聘请代理的对象）必须是某接口的实现类：
- 开发客户类，并且封装CRUD四个方法。
- 开发jdk代理公司类：实现 `InvocationHandler` 接口并重写 `invoke()` 工作清单：
    - param1：代理对象。
    - param2：代理方法的Method对象。
    - param3：代理方法的形参。
    - return：代理方法的返回值，若是 `void`，就返回 `null`。
- 开发聘用代理方法：核心代码为 `Proxy.newProxyInstance()`：
    - param1：客户的类加载器。
    - param2：客户的接口们。
    - param3：代理应该调用哪个类中的工作清单方法。
    - return：返回客户的代理对象。
- 设计工作清单内容：
    - 模拟业务方法前的工作，比如鉴权。
    - 利用反射执行业务方法。
    - 模拟业务方法后的工作，比如打印日志。
- 测试聘用代理的方法：
    - 创建客户并为客户聘用代理。
    - 将代理类型强转为客户接口类型，否则无法调用业务方法。

> z-res: jdk动态代理小说.md

**源码：** /spring4/
- src: `c.j.aop.proxy.JdkProxyCompany`
- src: `c.j.aop.proxy.UserService`
- src: `c.j.aop.proxy.UserServiceImpl`
- tst: `c.j.aop.JdkProxyTest.jdkProxy()`

# 2. cglib动态代理

**概念：** cglib是spring提供的动态代理，可以对任何非 `final` 的类进行代理：
- 开发客户类，并且封装CRUD四个方法。
- 开发cglib代理公司类：实现 `MethodInterceptor` 接口并重写 `intercept()` 工作清单：
    - param1：代理对象。
    - param2：代理方法的Method对象。
    - param3：代理方法的形参。
    - param4：方法的代理对象。
    - return：代理方法的返回值，若是 `void`，就返回 `null`。
- 开发聘用代理方法：核心代码为 `new Enhancer().create()`：
    - 创建之前需要设置客户的父类。
    - 创建之前需要设置回调对象，即代理应该调用哪个类中的工作清单方法。
- 设计工作清单内容：
    - 模拟业务方法前的工作，比如鉴权。
    - 利用反射执行业务方法。
    - 模拟业务方法后的工作，比如打印日志。
- 测试聘用代理的方法：
    - 创建客户并为客户聘用代理。
    - 将代理类型强转为客户接口类型，否则无法调用业务方法。

**源码：** /spring4/
- src: `c.j.aop.proxy.CglibProxyCompany`
- src: `c.j.aop.proxy.BearServiceImpl`
- tst: `c.j.aop.CglibProxyTest.cglibProxy()`

# 1. AOP概念

**概念：** AOP（Aspect Oriented Programming），面向切面编程，是OOP的延续，它是通过预编译的方式在运行期，使用动态代理来实现的一种技术，利用AOP可以实现业务代码和切面代码的逻辑分离，降低耦合度，从而提高程序的重用性。
- 切面相关词汇：在使用注解开发springAOP之前，你需要先了解以下概念：

单词 | 概念 | 描述
-|-|-
`Aspect`    | 切面 | 对横切性关注点的一种抽象
`JoinPoint` | 连接点 | 要被切的方法
`Pointcut`  | 切点 | 多个连接点的集合，可以拦截一个范围
`Advice`    | 通知 | 在连接点前后或异常情况下做的事情，包括前后、异常、最终和环绕通知
`Target`    | 目标对象 | 就是我们的客户，就是要使用代理的对象
`Weave`     | 织入 | 切面应用到目标对象，并且导致代理对象创建的过程

**举例说明：** 现在我想让 `UserServiceImpl` 类中的100个方法，在被调用之前判断一下用户是否已经登录，在被调用之后打印日志，于是想到聘用代理，那么：
- `UserServiceImpl`，就是客户 `Target`，因为接受我们代理的就是它。
- `UserServiceImpl` 里的100个方法，就是100个连接点 `JoinPoint`，当然如果某个方法设置了不使用代理，那它就不被称为连接点。
- 这100个连接点，可以组成一个切点 `Pointcut`，切点就是一个范围。
- 方法调用之前的内容，叫做前置通知 `Advice`。
- 方法调用之后的内容，叫做后置通知 `Adivce`。
- 方法调用的时候出了异常，触发异常通知 `Advice`。
- 方法返回结果之后执行的内容，叫做返回后通知 `Advice`。
- 一堆切点和一堆通知组成一个切面类 `Aspect`。
- 以上整个过程叫做织入 `Weave`。

## 3. Pointcut Expression表达式

**概念：** 不是所有的方法都需要AOP操作的，这时候我们需要对AOP的范围进行控制，AOP使用 `Pointcut Expression` 来指定哪些方法需要使用AOP操作，它作用于切点方法上的 `@Pointcut()` 中，是一个字符串表达式。
- **格式：** `execution([修饰符] 返回类型 [包名].[类名].方法名(方法参数) [异常])`
- **修饰符：**
    - `public`：切所有被 `public` 修饰的方法。
    - `public/private`：切所有被 `public` 或者 `private` 修饰的方法。
- **返回值：**
    - `*`：切所有类型返回值，包括 `void` 的方法。
    - `void`：切返回值为 `void` 的方法。
    - `void/java.lang.String`：切返回值为 `void` 或 `String` 的方法。
    - `!void`：切非 `void` 返回值的方法。
- **包名：**
    - `com.joe.service`：切 `com.joe.service` 包。
    - `com.joe.service..`：切 `com.joe.service` 包及其子孙包。
    - `com.joe.* / com.*.service`：通配符写法。
- **类名：**
    - `HelloWorld`：切 `HelloWorld` 类。
    - `*World`：切所有以 `World` 为后缀的类。
    - `Hello*`：切所有以 `Hello` 为前缀的类。
- **方法名：**
    - `CreateUser`：切 `CreateUser` 方法。
    - `*User`：切以 `User` 为后缀的方法。
    - `Create*`：切以 `Create` 为前缀的方法。
- **方法参数：** 
    - `..`：切任意方法参数的方法。
    - `*`：切只有一个参数的方法。
    - `java.lang.String,..`：切第一个参数为 `String`，后面随意的方法。

```!
execution() 中的内容大多数情况是由Pointcut Expression 表达式来描述的，此外还可以使用 args()、@args()、this()、target()、@target、within()、@within()、@annotation 等进行描述。
```

## 1. AOP依赖

**概念：** 想使用AOP注解开发，需要添加aspects切面依赖。

**配置：** pom.xml
```xml
<!--spring-aspects-->
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-aspects</artifactId>
    <version>${spring}</version>
</dependency>
```

## 2. 客户类

**源码：** CustomerService.java
```java
/**
 * @author JoeZhou
 */
@Service
public class CustomerService {}
```

## 3. 切面类

**概念：** 
- 切面类必须由 `@Aspect` 和 `@Component` 组合修饰，声明此类为切面类且可以被spring容器扫描并管理。
- 切面类中需要包括切点方法，配合 `@Pointcut("execution()")` 来指定切点范围，即哪些方法需要被执行AOP。
- 切点方法名随意，一个类中可以有多个切点方法，方法名仅仅用来区别它们，但切点方法必须是空方法。
    
**源码：** CustomerAspectByAnn.java
```java
/**
 * @author JoeZhou
 */
@Aspect
@Component
public class CustomerAspectByAnn {

    @Pointcut("execution(public * com.joe.service..*.*(..))")
    public void myPointCut() {}
}
```

## 4. XML配置

**概念：** AOP相关的配置需要引入AOP的xsd约束。

**配置：** spring/aop/app-customer-ann.xml
```xml
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xmlns:context="http://www.springframework.org/schema/context"
       xmlns:aop="http://www.springframework.org/schema/aop"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd
        http://www.springframework.org/schema/context
        http://www.springframework.org/schema/context/spring-context.xsd
        http://www.springframework.org/schema/aop
        http://www.springframework.org/schema/aop/spring-aop.xsd">

    <!-- 包扫描只能扫@Component注解 -->
    <context:component-scan base-package="com.joe.dao"/>
    <context:component-scan base-package="com.joe.service"/>
    <context:component-scan base-package="com.joe.aspect"/>

    <!-- 负责扫@Aspect注解 -->
    <aop:aspectj-autoproxy/>

</beans>
```
