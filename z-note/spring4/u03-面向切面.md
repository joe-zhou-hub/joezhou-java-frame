# 1. jdk动态代理

**概念：** JDK动态代理的客户对象必须是某接口的实现类，即普通类不可以使用此种代理。

# 2. 准备客户类

**概念：** 我们先来准备一个，符合JDK动态代理要求条件的客户。

**源码：** 接口：UserService.java
```java
/**
 * @author JoeZhou
 */
public interface UserService {

    /**
     * 模拟添加一个用户
     */
    void create();

    /**
     * 模拟修改一个用户
     */
    void update();
}
```

**源码：** UserServiceImpl.java
```java
/**
 * @author Joe
 */
public class UserServiceImpl implements UserService {

    @Override
    public void create() {
        System.out.println("添加用户...");
    }

    @Override
    public void update() {
        System.out.println("修改用户...");
    }
}
```

# 3. 创建JDK代理公司类

**概念：** 创建JDK代理公司类，要求代理公司类必须实现 `java.lang.reflect.InvocationHandler` 接口并重写 `invoke()`，`invoke()` 是代理的工作内容清单，它有三个参数：
- p1：代理对象。
- p2：代理的方法对象。
- p3：代理的方法的参数。
- return：代理的方法的返回值，如果是 `void`，就返回 `null`。

**源码：** JdkProxyCompany.java
```java
/**
 * @author JoeZhou
 */
public class JdkProxyCompany implements InvocationHandler {

    @Override
    public Object invoke(Object proxy, Method method, Object[] args) 
        throws InvocationTargetException, IllegalAccessException {
        
        return null;
    }
}
```

# 4. 设计聘用代理的方法

**概念：** 代理类中只有一个 `invoke()` ，还是不够的，我们需要补充一个聘用代理的方法 `hireProxy()`，在代理方法中调用 `java.lang.reflect.Proxy` 的静态方法 `newProxyInstance()` 来返回一个跟客户的接口同名的代理对象，该静态方法有三个参数：
- p1：客户的类加载器。
- p2：客户的接口们。
- p3：代理应该调用哪个类中的工作清单 `invoke()` 方法。

**源码：** JdkProxyCompany.java中添加 `hireProxy()`
```java
/*客户*/
private Object customer;

/**
 * 只要调用这个hireProxy()方法，就能成功的为指定的客户聘请一个JDK代理
 *
 * @param customer 想要聘用代理的客户
 * @return 对应客户的代理
 */
public Object hireProxy(Object customer) {

    // 将客户作用域上升，以便invoke()也能看到客户
    this.customer = customer;

    ClassLoader classLoader = customer.getClass().getClassLoader();
    Class<?>[] interfaces = customer.getClass().getInterfaces();
    return Proxy.newProxyInstance(classLoader, interfaces, this);
}
```

# 5. 设计工作清单内容

**概念：** 设计代理工作清单 `invoke()` 的内容：
1. 模拟业务方法前的工作。
2. 让代理帮我们干活：利用反射回调执行业务方法。
3. 模拟业务方法后的工作。

**源码：** JdkProxyCompany.java中补充 `invoke()`
```java
System.out.println("tx:setAutoCommit(false)");
Object methodReturn = method.invoke(customer, args);
System.out.println("tx:commit and setAutoCommit(true)");
return methodReturn;
```

# 6. 代理测试

**源码：** junit测试
```java
@Test
public void jdkProxy() {

    // 创建客户：这里使用实现类类型接收也一样
    UserService zhaosi = new UserServiceImpl();

    // 创建JDK代理公司
    JdkProxyCompany company = new JdkProxyCompany();

    // 从公司中为zhaosi聘用一个代理，需要把zhaosi传入方法
    // 代理必须被强转成客户类型，即代理的类型要和客户类型一致
    UserService liuneng = (UserService) company.hireProxy(zhaosi);

    // 虽然是用客户接口UserService接收的，但实际上它是一个代理类型
    System.out.println(liuneng.getClass());

    // 让代理干活：代理开始执行工作清单invoke()中的代码
    liuneng.create();
    liuneng.update();
}
```

# 7. JDK代理理解故事

- 我是一名自于 `UserService` 公司的老板，目前我们公司主营的四个业务是增删改查 ，我希望在每个业务执行之前都能“关闭自动提交”，在每个业务之后都能“手动提交并且恢复自动提交”，如果每个业务都手动添加这两套代码的话实在是太麻烦了，所以我想去代理公司，和他们谈谈合作。

- 经过高人的指点，我来到了一个僻静的小山村，映入眼帘的是两家代理公司，一家叫JDK动态代理公司，一家叫CGLIB动态代理公司，我准备先去JDK动态代理公司碰碰运气。

- 走进这家代理公司，迎面走出来一个人，满脸堆笑的对我说：“欢迎光临，这里是JDK代理公司，全名 `JdkProxyCompany`，我们公司是合理合法的正规公司，这是我们公司的营业证明，请问您是需要聘请代理帮您做事吗？”

- 说着，他拿出一个公司营业许可证明文件给我看，我看到如下内容：

```java
public class JdkProxyCompany implements InvocationHandler{
    
}
```

- "是的，我是 `UserService` 公司的老板，想跟贵公司谈谈合作。"

- "没问题，但是有一点我需要事先说明，我们公司有明文规定，只代理有接口的客户，因为我们的代理也需要来实现您的客户的接口，如果您的客户没有实现任何接口，请您出门左转，去隔壁cglib他们家聘用代理。" 

- "这个可以，我们公司都是接口加实现类的工作模式。" 我回答道。

- "好的，接下来我会为您进行登记，请您编写一个召唤代理的咒语好吗？" 说着，他拿出一个本子，准备在上面写些什么。

- "咒语的话，我觉得，要不然就叫 `hireProxy` 吧！" 我回答道。

- "没问题，对了，召唤代理的时候，您还需要告诉我们为您公司的哪位员工进行代理，因为他才是我们的具体的客户对象，我们也需要为他进行登记。" 说着，他在本上写下如下内容：

```java
private Object customer; 
public Object hireProxy(Object customer){
    this.customer = customer;  
}
```

- "接下来，我要为您编写这个咒语了，对了，召唤代理的时候，需要提供具体客户的类加载器和接口数组们，否则召唤不了代理哦，不要担心这个，就像您开房要提供身份证信息一样，我们也会为您保密这些信息的。"  说着，他在咒语的方法 `hireProxy()` 中又添加了如下内容：

```java
ClassLoader classLoader= customer.getClass().getClassLoader();
Class[] interfaces = customer.getClass().getInterfaces();
return Proxy.newProxyInstance(classLoader,interfaces,this);  
```

- "好了，咒语已经编写完成了，以后想召唤代理的时候，您只需要喊出 `hireProxy()`，就可以召唤一个代理了，那么接下来，您需要提供一下代理的工作清单 `invoke()`，也就是告诉我们，您聘用代理，需要它们做些什么内容，您召唤的代理会按照这个清单一步一步执行的。" 

- "嗯，我需要这个代理在帮我做任何事之前，都能帮我关闭自动提交，并且在做完事之后，帮我手动提交并且恢复自动提交。"

- "好的。" 说着他又拿出另一张表，并写了如下内容：

```java
@Override
public Object invoke(Object proxy, Method method, Object[] args)     throws Throwable {

    System.out.println("模拟业务方法之前的工作");
    System.out.println("tx:setAutoCommit(false)...");
    Object returnValue = method.invoke(customer, args);	
    System.out.println("模拟业务方法之后的工作");
    System.out.println("tx:commit and setAutoCommit(true)...");
    return returnValue;
}
```

- 我又问道：“需要我提前告诉您，我们要做的事情吗？”

- "这个不需要，我们代理的工作模式是预编译，会自动在您使用代理的时候，通过反射的方式了解到您要做的业务方法，然后帮您去做( `method.invoke()` )，但是每次都需要提供具体的客户和方法的参数，当然，最后我们会把业务方法的结果给您返回去。" 边说着，他边指给我看，我看到了这样一行代码：

```java
Object returnValue = method.invoke(customer, args);	
```

- "哦，明白了。"

- "好的，您的手续都已经全部都办理完了，您接下来可以找一名客户来测试一下了。"

- 我走出门，掏出电话，打给我们公司最勤劳的，也是专门负责增删改查的员工赵四，让它帮我试试代理好不好用。

- "喂，老四啊，不用再自己添加前后方法了，我给你找了个代理，咒语是 `hireProxy()`，试试好不好使！"

```java
// 我的员工[赵四]
UserService zhaosi = new UserServiceImpl();

// 实例化JDK代理公司
JdkProxyCompany JdkProxyCompany = new JdkProxyCompany();
```

- 赵四挂了电话之后找到一处空旷的地方大声喊出了咒语：`hireProxy()!`，突然砰的一声！身边多出一个人，居然跟赵四长得一模一样！

```java
// 为赵四聘用一个代理，代理叫刘能
UserService liuneng = (UserService) JdkProxyCompany.hireProxy(zhaosi);
```

- 这个人说道：“你好，我是你的代理，我叫刘能，你想要调用 `create()` 和 `update()` 是吧？那么接下来，就交给我了！”

```java
liuneng.create();
liuneng.update();
```

- 嗯！结果非常完美，赵四出色的完成了我布置的任务，哦不对，是他的代理刘能，出色的完成了我布置的任务。
