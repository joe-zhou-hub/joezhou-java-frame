# 1. jdk动态代理

**概念：** jdk动态代理的客户（聘请代理的对象）必须是某接口的实现类：
- 开发客户类，并且封装CRUD四个方法。
- 开发jdk代理公司类：实现 `InvocationHandler` 接口并重写 `invoke()` 工作清单：
    - param1：代理对象。
    - param2：代理方法的Method对象。
    - param3：代理方法的形参。
    - return：代理方法的返回值，若是 `void`，就返回 `null`。
- 开发聘用代理方法：核心代码为 `Proxy.newProxyInstance()`：
    - param1：客户的类加载器。
    - param2：客户的接口们。
    - param3：代理应该调用哪个类中的工作清单方法。
    - return：返回客户的代理对象。
- 设计工作清单内容：
    - 模拟业务方法前的工作，比如鉴权。
    - 利用反射执行业务方法。
    - 模拟业务方法后的工作，比如打印日志。
- 测试聘用代理的方法：
    - 创建客户并为客户聘用代理。
    - 将代理类型强转为客户接口类型，否则无法调用业务方法。

> z-res: jdk动态代理小说.md

**源码：** /spring4/
- src: `c.j.aop.proxy.JdkProxyCompany`
- src: `c.j.aop.proxy.UserService`
- src: `c.j.aop.proxy.UserServiceImpl`
- tst: `c.j.aop.JdkProxyTest.jdkProxy()`

# 2. cglib动态代理

**概念：** cglib是spring提供的动态代理，可以对任何非 `final` 的类进行代理：
- 开发客户类，并且封装CRUD四个方法。
- 开发cglib代理公司类：实现 `MethodInterceptor` 接口并重写 `intercept()` 工作清单：
    - param1：代理对象。
    - param2：代理方法的Method对象。
    - param3：代理方法的形参。
    - param4：方法的代理对象。
    - return：代理方法的返回值，若是 `void`，就返回 `null`。
- 开发聘用代理方法：核心代码为 `new Enhancer().create()`：
    - 创建之前需要设置客户的父类。
    - 创建之前需要设置回调对象，即代理应该调用哪个类中的工作清单方法。
- 设计工作清单内容：
    - 模拟业务方法前的工作，比如鉴权。
    - 利用反射执行业务方法。
    - 模拟业务方法后的工作，比如打印日志。
- 测试聘用代理的方法：
    - 创建客户并为客户聘用代理。
    - 将代理类型强转为客户接口类型，否则无法调用业务方法。

**源码：** /spring4/
- src: `c.j.aop.proxy.CglibProxyCompany`
- src: `c.j.aop.proxy.BearServiceImpl`
- tst: `c.j.aop.CglibProxyTest.cglibProxy()`

# 3. AOP概念

**概念：** Aspect Oriented Programming，面向切面编程，是OOP的延续，它通过预编译的方式在运行期，使用动态代理来实现业务代码和切面代码的逻辑分离，降低耦合度，从而提高程序的重用性：
- AOP技术名词：想让A类中的10个方法在被调用前鉴权，被调用后打印日志，那么：
    - A类，称为客户 `Target`，因为聘用代理的就是它。
    - A类里的方法，称为连接点 `JoinPoint`，设置了不使用代理的方法不算连接点。
    - A类中所有的连接点会组成一个切点 `Pointcut`，切点是一个范围。
    - 连接点调用前后所进行的处理，称为前后通知 `Advice`。
    - 连接点调用出现异常时进行的处理，称为异常通知 `Advice`。
    - 连接点return后进行的处理，称为返回后通知 `Advice`。
    - 一堆切点和一堆通知组成一个切面类 `Aspect`。
    - 以上整个过程叫做织入 `Weave`。
- PE表达式：Pointcut Expression字符串表达式，作用于切点方法上的 `@Pointcut()` 中，用于指定哪些方法需要使用AOP操作，其中 `*` 表示1个占位，`..` 表示任意占位：
    - 模板：`execution([修饰符] 返回类型 [包名].[类名].方法名(形参) [异常])`
    - 修饰符：如 `public`，`public/private` 等，缺省表示友元修饰符。
    - 返回值：如 `*`，`void`，`void/java.lang.String`，`!void` 等。
    - 包名：如 `c.j.service`，`c.j.service..`，`c.j.*`，`c.*.service` 等。
    - 类名：如 `HelloWorld`，`*World`，`Hello*` 等。
    - 方法名：如 `InsertUser`，`*User`，`Insert*` 等。
    - 形参：如 `..`，`*`，`int,..`等

> 除PE表达式外，还可以用args()、@args()、this()、target()、@target、within()、@within()、@annotation 等进行范围描述。

## 3.1 AOP准备

**概念：**
- 添加 `spring-aspects` 切面依赖。
- 开发客户类：需要被spring容器扫描和管理：
    - `public void delete(String name, Integer id)`
    - `public List<String> select(String name)`
    - `public void update(Map<String, Object> user)`
- 开发切面类：需要被spring容器扫描和管理：
    - 类上添加 `@Aspect` 表示这是一个切面类。
- 开发核心配置文件：
    - 包扫描 `@Component`。
    - 使用 `<aop:aspectj-autoproxy/>` 驱动 `@Aspect` 注解。

**源码：** /spring4/
- res: `pom.xml`
- res: `classpath:spring/aop/customer-annotation.xml`
- src: `c.j.aop.aspect.CustomerService`
- src: `c.j.aop.aspect.CustomerAspectByAnnotation`

## 3.2 前后通知

**概念：** 前后通知就是在方法执行前后做一些事，但无法阻止方法的运行：
- 在切面类中开发切点方法：方法名随意仅用于区分，但方法体必须为空：
    - 方法添加 `@Pointcut("execution(* com.joezhou.aop.aspect..*.delete(..))")`
- 在切面类中开发前后通知方法，并在注解中指定带括号的切点方法名：
    - 前置通知方法需要添加 `@Before`。
    - 后置通知方法需要添加 `@After`。
- 若想在前置通知方法中获取业务方法形参：
    - 在注解中的切点方法名后附加 `&&args(形参列表)`。
    - 在注解中添加额外的 `argNames="形参列表"`，更规范。
    - 对通知方法添加形参，类型与业务方法一致，名与 `args()` 中一致。

**源码：** /spring4/
- src: `c.j.aop.aspect.CustomerAspectByAnnotation.deletePointCut()`
- src: `c.j.aop.aspect.CustomerAspectByAnnotation.beforeAdvice()`
- src: `c.j.aop.aspect.CustomerAspectByAnnotation.afterAdvice()`
- tst: `c.j.aop.CustomerTest.beforeAndAfterAdvice()`

## 3.2 返回后通知

**概念：** 返回后通知就是在业务方法return之后做的是事情：
- 在切面类中开发切点方法：方法名随意仅用于区分，但方法体必须为空：
    - 方法添加 `@Pointcut("execution(* com.joezhou.aop.aspect..*.select(..))")`
- 在切面类中开发返回后通知方法，并在注解中指定带括号的切点方法名：
    - 返回后通知方法需要添加 `@AfterReturning`。
    - 在注解中添加额外的 `returning` 属性指定方法的返回值。
    - 对通知方法添加形参，类型与业务方法返回值一致，名与 `returning` 的值一致。
- 若想在返回后通知方法中获取业务方法形参，一样可以使用 `args()`。

**源码：** /spring4/
- src: `c.j.aop.aspect.CustomerAspectByAnnotation.selectPointCut()`
- src: `c.j.aop.aspect.CustomerAspectByAnnotation.afterReturningAdvice()`
- tst: `c.j.aop.CustomerTest.AfterReturningAdvice()`

## 3.3 异常通知

**概念：** 
- 异常通知就是在方法发生异常之后想做点事。
- 异常通知的方法需要配合 `@AfterThrowing` ，`@AfterThrowing` 中需要指定切点方法。
- `@AfterThrowing` 中使用 `throwing` 来获取方法的异常对象，它的值必须和所在方法的中形参的名一致。

**源码：** CustomerAspect.java中添加：
```java
@AfterThrowing(pointcut = "myPointCut()", throwing = "e")
public void afterThrowingAdvice(Exception e) {
    System.out.println("程序异常：" + e);
}
```

**源码：** junit测试
```java
@Test
public void afterThrowing() {
    String configLocation = "spring/aop/app-customer-ann.xml";
    ClassPathXmlApplicationContext app = new ClassPathXmlApplicationContext(configLocation);
    CustomerService customerService = app.getBean(CustomerService.class);
    customerService.exception();
    app.close();
}
```

## 3. 异常通知获取参数

**概念：** 可以在异常通知中，配合 `args()` 获取业务方法参数。

**源码：** CustomerAspect.java中添加：
```java
@AfterThrowing(pointcut = "myPointCut()&&args(name)", 
    throwing = "e", 
    argNames = "name,e")
public void afterThrowingAdvice(String name, Exception e) {
    System.out.println("业务方法参数：" + name);
    System.out.println("程序异常：" + e);
}
```

**源码：** junit测试	
```java
@Test
public void afterThrowingWithParams() {
    String configLocation = "spring/aop/app-customer-ann.xml";
    ClassPathXmlApplicationContext app = new ClassPathXmlApplicationContext(configLocation);
    CustomerService customerService = app.getBean(CustomerService.class);
    customerService.exceptionWithParams("ex");
    app.close();
}
```