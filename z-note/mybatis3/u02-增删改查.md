# 1. SQL配置文件

**概念：** SQL配置文件用于配置SQL语句块以及SQL相关配置：
- 开发实体类：数据库主键无符号使用Integer对应，有符号使用Long对应。
- 配置别名：除mybatis内置别名外，核心配置文件中的 `<typeAliases>` 可配置自定义别名：
   - `<typeAlias type="类全名" alias="别名">`：单类配置别名。
   - `<package name="包名">`：整包配置别名，此时类名即别名，不区分大小写。
- 开发SQL配置文件：配置根标签 `<mapper>` 的 `namespace` 以隔离语句。 
- 引入SQL配置文件：在核心配置文件中使用 `<mappers resource="">` 引入。
- 取消IDEA中SQL语句黄绿色背景：`File` - `Settings` - `Editor`：
    - `Inspections` - `SQL` - 取勾 `No data sources configured` 和 `SQL dialect detection`
    - `Color Scheme` - `General` - `Code` - `Injected language fragment` - 取勾 `Background`

> mybatis内置别名.md

**源码：** /mybatis3/
- res: `classpath:mybatis-crud.xml`
- res: `classpath:mapper/student-mapper.xml`
- res: `classpath:mapper/worker-mapper.xml`
- res: `classpath:mapper/teacher-mapper.xml`
- src: `c.j.pojo.Student/Worker/Teacher`

# 2. DML语句块

**流程：** DML操作可以省略 `parameterType`，必须省略 `resultType`：
- 开发 `<insert id="insert">`：单表添加普通版语句块：
    - `useGeneratedKeys="true"`：启用主键回注机制。
    - `keyProperty="id"`：指定主键回注到哪个字段中。
- 开发 `<insert id="insertWithSelectKey">`：单表添加SelectKey版语句块：
    - `<selectKey>`：设置子语句块，伴随 `<insert>` 一同执行。
    - `order="BEFORE"`：设置子语句块在 `<insert>` 语句之前执行。
    - `keyProperty="id"`：设置子语句块的查询结果回注到 `id` 字段中。
    - `resultType`：指定回注字段的类全名，不可省略。
    - `SELECT last_insert_id()`：返回最后一条插入记录的注解。
    - `SELECT uuid()`：返回一个随机字符串。
- 开发 `<update id="updateById">`：单表修改语句块。
- 开发 `<delete id="deleteById">`：单表删除语句块。
- 开发SQL语句： 支持占位符 `#{}` 时，自动补充单引号：
    - 参数若为实体类，则占位符中必须为实体类中对应属性名，支持多级连调。
    - 参数若为简单类，则占位符中内容可以随意填写，但不能不写。
- 测试：
    - `session.insert("命名空间.SQL语句块ID", 入参)`：添加数据。
    - `session.update("命名空间.SQL语句块ID", 入参)`：修改数据。
    - `session.delete("命名空间.SQL语句块ID", 入参)`：删除数据。

**源码：** /mybatis3/
- res: `classpath:mapper/student-mapper.xml`
- tst: `c.j.crud.StudentTest.insert()`
- tst: `c.j.crud.StudentTest.insertWithSelectKey()`
- tst: `c.j.crud.StudentTest.updateById()`
- tst: `c.j.crud.StudentTest.deleteById()`

# 3. DQL语句块

**流程：** DQL可以省略 `parameterType`，必须使用 `resultType` 指定返回值或其泛型的类全名或别名：
- 开发 `<select id="findById">`：单表单查语句块。
- 开发 `<select id="findLikeName">`：单表多查拼接符版语句块。
- 开发 `<select id="findLikeNameWithConcat">`：单表多查占位符版语句块。
- 开发SQL语句：支持拼接符 `${value}` 时，不会自动补充单引号，有注入漏洞：
    - 参数若为实体类，则占位符中必须为实体类中对应属性名，支持多级连调。
    - 参数若为简单类，则占位符中内容必须是 `value`。
- SQL重用块：`<sql id="">` 用来封装一个SQL代码段，然后本文件中任意位置可以使用 `<include refid="">` 来引用它。
- SQL注入漏洞：此WEB漏洞的本质是将用户输入的数据当做代码执行以攻击系统：
    - `like '%${value}%'`：有漏洞，若攻击者传入 `'or'` 时会直接执行全查。
    - `like concat('%', #{name}, '%')`：无注入漏洞问题。
- DQL语句块其他属性：
    - `resultMap`：引用 `<resultMap>` 的id 名，不能与 `resultType` 同时使用。 
    - `flushCache`：每次调用该语句块前是否清空其缓存以保证结果最新，默认 `false`。
    - `useCache`：该语句块的结果集是否会被缓存，默认 `true`。
    - `timeout`：语句块超时时间，默认数值由驱动器决定。
    - `fetchSize`：结果集条目数达到此阈值时立刻返回结果，默认数值由驱动器决定。
    - `statementType`：SQL媒介类型默认为预处理 `PREPARED`，可改为不预处理 `STATEMENT` 或存储过程 `CALLABLE`。
- 测试：
    - `session.selectOne("命名空间.SQL语句块ID", 入参)`：查询单条数据。
    - `session.selectList("命名空间.SQL语句块ID", 入参)`：查询多条数据。

**源码：** /mybatis3/
- res: `classpath:mapper/student-mapper.xml`
- tst: `c.j.crud.StudentTest.selectOne()`
- tst: `c.j.crud.StudentTest.findLikeName()`
- tst: `c.j.crud.StudentTest.findLikeNameWithConcat()`

## 3.2 二级缓存

**概念：** mybatis默认只开启session一级缓存，二级缓存需配置 `<cache>`，此时所有DQL都会被缓存，所有DML都会更新缓存：
- `eviction`：缓存逐出机制，一共有4种预定义机制：
    - LRU： 逐出最长时间不被使用的对象，默认值。
    - FIFO： 先进先出：按对象进入缓存的顺序逐出。
    - SOFT： 软引用：按照GC规则逐出。
    - WEAK： 弱引用：更积极地按照GC规则逐出。
- `flushInterval`：缓存刷新间隔，单位毫秒，默认不设置，表示缓存仅仅调用语句时刷新。
- `readOnly`：默认 `false`，所有调用者都只能通过序列化得到一个缓存对象的拷贝，效率低但安全，若改为 `true`，所有调用者得到的都是相同的缓存对象，性能高但不安全。
-  `size`：缓存大小，默认1024个，表示缓存会存储1024个列表集合或对象的引用。
-  `type`：覆盖缓存类，允许使用第三方或者自定义缓存的类全名，覆盖mybatis的预定义缓存机制。
- 如果你想在命名空间中共享相同的缓存配置和实例，你可以使用 `<cache-ref>` 来指定。

## 3.3 高级映射标签

**概念：** 
- 当实体类POJO中的字段和数据库中的列名不一致时，可以使用 `resultMap` 替代 `resultType` ，其值指向一个独立的 `<resultMap>` 的 `id`，在这个独立的 `<resultMap>` 中可以详细地配置实体类属性和数据库表列名的映射关系。
    - `id`：`<resultMap>` 的唯一标识。
    - `type`：最终返回值类型全名或别名。
- `<resultMap>` 使用子标签 `<result>` 来映射字段：
    - `column`：表字段名。
    - `jdbcType`：表字段类型，必须大写，是一个枚举类型，支持的枚举类型列表见图3-1。
    - `property`：实体类POJO的属性名。
    - `javaType`：实体类POJO的属性类型，可以省略。
- `<resultMap>` 和 `<resultType>` 不能同时使用。

![](https://user-gold-cdn.xitu.io/2020/5/26/1724ff4d6063ff41?w=800&h=158&f=png&s=36924 "图3-1")

**配置：** StudentMapper.xml
```xml
<resultMap id="retrieveByIdMap" type="student">
    <result column="stu_name" property="stuName" javaType="string" jdbcType="VARCHAR"/>
    <result column="stu_age" property="stuAge" jdbcType="VARCHAR"/>
    <result column="stu_gender" property="stuGender"/>
    <result column="stu_info" property="stuInfo"/>
</resultMap>

<select id="retrieveById" resultMap="retrieveByIdMap">
    SELECT `id`, `stu_name`, `stu_age`, `stu_gender`, `stu_info`
    FROM `student` WHERE `id` = #{id}
</select>
```

# 4. 接口开发

**流程：** 接口动态代理模式需要额外开发一个遵守对应关系的java接口：
- 四大对应：
    - 接口类全名对应SQL配置文件的 `namespace`。
    - 接口方法返回值类型对应SQL语句块的 `resultType`。
    - 接口方法方法名对应SQL语句块的 `id`。
    - 接口方法形参对应SQL语句块的 `parameterType`。
- 测试：`session.getMapper()`：获取接口对象后直接调用接口方法。

**源码：** /mybatis3/
- res: `classpath:mapper/worker-mapper.xml`
- src: `c.j.mapper.WorkerMapper`
- tst: `c.j.crud.WorkerTest`

## 4.2 注解SQL

**流程：** 接口开发模式下，可使用注解替代SQL语句块，虽简化了代码，但不适用于复杂SQL：
- 开发SQL配置文件：即使不写SQL语句块，`namespace` 仍要对应接口类全名。
- 开发接口：在接口方法上直接使用注解来完成SQL的编写：
    - `@Select/@Insert/@Update/@Delete`：编写增删改查的SQL语句。
    - `@Options`：用于配置缓存，超时时间，主键回注等。
- 测试：`session.getMapper()`：获取接口对象后直接调用接口方法。

**源码：** /mybatis3/
- res: `classpath:mapper/teacher-mapper.xml`
- src: `c.j.mapper.TeacherMapper`
- tst: `c.j.crud.TeacherTest`