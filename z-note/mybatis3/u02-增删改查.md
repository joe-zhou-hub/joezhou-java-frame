# 1. SQL配置文件

**概念：** SQL配置文件用于配置SQL语句块以及SQL相关配置：
- 开发实体类：与数据库表形成ORM关系。
- 开发SQL配置文件：
    - 必须在根标签 `<mapper>` 中指定 `namespace` 以隔离语句。 
    - SQL语句末尾添加分号对结果无影响。
- 配置SQL配置文件：必须在核心配置文件中使用 `<mappers>` 引入：
    - 使用 `resource` 属性引入时路径从classpath出发，且不以 `/` 开头。
- 取消IDEA中SQL语句黄绿色背景：`File` - `Settings`：
    - `Inspections` - `SQL` - 取勾 `No data sources configured` 和 `SQL dialect detection`。
    - `Color Scheme` - `General` - `Code` - `Injected language fragment` - 取勾 `Background`。

**源码：** /mybatis3/
- res: `classpath:mybatis-crud.xml`
- res: `classpath:mapper/student-mapper.xml`
- res: `classpath:mapper/teacher-mapper.xml`
- res: `classpath:mapper/worker-mapper.xml`
- res: `classpath:mapper/leader-mapper.xml`
- src: `c.j.pojo.Student`
- src: `c.j.pojo.Teacher`
- src: `c.j.pojo.Worker`
- src: `c.j.pojo.Leader`

# 2. 单表添加

**流程：**
- 开发 `<insert id="insert">` 和 `<insert id="insertWithSelectKey">`：
    - `parameterType`：语句块参数类型或别名，可省略。
    - `resultType`：添加业务没有返回值，必须省略。
    - `useGeneratedKeys="true"`：启用主键回注机制。
    - `keyProperty="id"`：指定主键回注到哪个字段中。
- 开发SQL语句： 使用占位符 `#{}` 时，自动补充单引号：
    - 参数若为实体类，则占位符中必须为实体类中对应属性名，支持多级连调。
- 子语句块 `<selectKey>`： 伴随 `<insert>` 一同执行：
    - `order`：`BEFORE/AFTER` 表示该语句在 `<insert>` 语句之前/之后执行。
    - `keyProperty="id"`：指定该语句的查询结果回注到哪个字段中。
    - `resultType`：指定回注字段的类全名，不可省略。
    - `SELECT last_insert_id()`：返回最后一条插入记录的注解。
    - `SELECT uuid()`：返回一个随机字符串。
- 测试：使用 `session.insert("命名空间.SQL语句块ID", 入参)` 添加数据。

**源码：** /mybatis3/
- res: `classpath:mapper/student-mapper.xml`
- res: `classpath:mapper/teacher-mapper.xml`
- tst: `c.j.crud.StudentTest.insert()`
- tst: `c.j.crud.StudentTest.insertWithSelectKey()`
- tst: `c.j.crud.TeacherTest.insertWithSelectKey()`

# 3. 单表单查

**流程：** 
- 开发 `<select id="findById">`：
    - `parameterType`：语句块参数类型或别名，可省略。
    - `resultType`：语句块返回值类型或别名。
- 开发SQL语句：使用占位符 `#{}` 时，自动补充单引号：
    - 参数若为简单类，则占位符中内容可以随意填写，但不能不写。
- 其他属性：
    - `resultMap`：引用 `<resultMap>` 的id 名，不能与 `resultType` 同时使用。 
    - `flushCache`：每次调用该语句块前是否清空其缓存以保证结果最新，默认 `false`。
    - `useCache`：该语句块的结果集是否会被缓存，默认 `true`。
    - `timeout`：语句块超时时间，默认数值由驱动器决定。
    - `fetchSize`：结果集条目数达到此阈值时立刻返回结果，默认数值由驱动器决定。
    - `statementType`：SQL发送媒介类型：
        - `PREPARED`：预处理媒介，默认。 
        - `STATEMENT`：不预处理媒介。
        - `CALLABLE`：存储过程媒介。
    - `resultSetType`：结果集处理类型，默认值由驱动器决定：
        - `FORWARD_ONLY`：只转发。
        - `SCROLL_SENSITIVE`：update操作对ResultSet的next()有影响。
        - `SCROLL_INSENSITIVE`：update操作对ResultSet的next()无影响。
- 测试：使用 `session.selectOne("命名空间.SQL语句块ID", 入参)` 查询单条数据。

**源码：** /mybatis3/
- res: `classpath:mapper/student-mapper.xml`
- tst: `c.j.crud.StudentTest.selectOne()`

# 4. 单表多查

**流程：**
- 开发 `<select id="findLikeName">` 和 `<select id="findLikeNameWithConcat">`：
    - `parameterType`：语句块参数类型或别名，可省略。
    - `resultType`：语句块返回值类型或别名，若返回集合，则填写泛型类全名或别名即可。
- 开发SQL语句：使用拼接符 `${value}` 时，不会自动补充单引号：
    - 参数若为实体类，则占位符中必须为实体类中对应属性名，支持多级连调。
    - 参数若为简单类，则占位符中内容必须是 `value`。
- SQL注入漏洞：此WEB漏洞的本质是将用户输入的数据当做代码执行以攻击系统：
    - `like '%${value}%'`：有漏洞，若攻击者传入 `'or'` 时会直接执行全查。
    - `like concat('%', #{name}, '%')`：无注入漏洞问题。
- 测试：使用 `session.selectList("命名空间.SQL语句块ID", 入参)` 查询多条数据。

**源码：** /mybatis3/
- res: `classpath:mapper/student-mapper.xml`
- tst: `c.j.crud.StudentTest.findLikeName()`
- tst: `c.j.crud.StudentTest.findLikeNameWithConcat()`

# 5. 单表修改

**流程：** 
- 开发 `<update id="updateById">`：
    - `parameterType`：语句块参数类型或别名，可省略。
    - `resultType`：修改业务没有返回值，必须省略。
- 开发SQL语句：使用占位符 `#{}`。
- 测试：使用 `session.update("命名空间.SQL语句块ID", 入参)` 修改数据。

**源码：** /mybatis3/
- res: `classpath:mapper/student-mapper.xml`
- tst: `c.j.crud.StudentTest.updateById()`

# 6. 单表删除

**流程：** 
- 开发 `<delete id="deleteById">`：
    - `parameterType`：语句块参数类型或别名，可省略。
    - `resultType`：删除业务没有返回值，必须省略。
- 开发SQL语句：使用占位符 `#{}`。
- 测试：使用 `session.delete("命名空间.SQL语句块ID", 入参)` 删除数据。

**源码：** /mybatis3/
- res: `classpath:mapper/student-mapper.xml`
- tst: `c.j.crud.StudentTest.deleteById()`

# 7. 接口开发

**概念：** 接口动态代理方式需要额外配置一个接口，必须遵守如下对应关系：
- 接口类全名对应SQL配置文件的 `namespace`。
- 接口方法返回值类型对应SQL语句块的 `resultType`。
- 接口方法方法名对应SQL语句块的 `id`。
- 接口方法形参对应SQL语句块的 `parameterType`。

**源码：** /mybatis3/
- res: `classpath:mapper/worker-mapper.xml`
- src: `c.j.mapper.WorkerMapper`
- tst: `c.j.crud.WorkerTest`

# 8. 注解开发

**概念：** 
- 如果你使用的是接口开发Dao的方式，则还有一个映射的办法，就是不在Mapper配置文件中写SQL语句，而是使用java注解来完成。
- 这种方案如果是对于简单的SQL语句来说会变得更清晰，但并不适用于复杂的SQL语句，且没有做到SQL和java的分离，所以具体使用哪种方式开发，需要慎重考虑。

## 2. Mapper配置

**概念：** 即使不写任何SQL代码，这个文件也必须要存在，`namespace` 仍要对应Mapper接口类全名，主配文件中也照常配置它。

**配置** StudentMapper.xml
```xml
<mapper namespace="com.joe.mapper.StudentMapper">

</mapper>
```

## 3. Mapper接口

**概念：** 在接口方法上可以直接使用注解来完成SQL的编写：
- `@Select`：查询SQL。
- `@Insert`：添加SQL。
    - `@Options`：配置主键回注。
- `@Update`：修改SQL。
- `@Delete`：删除SQL。

**源码：** StudentMapper.java
```java
/**
 * @author JoeZhou
 */
public interface StudentMapper {

    /**
     * 根据主键查询一条信息
     * @param id 主键
     * @return 对应主键的一条信息
     */
    @Select("SELECT `id`,\n" +
            "   `stu_name` stuName,\n" +
            "   `stu_age` stuAge,\n" +
            "   `stu_gender` stuGender,\n" +
            "   `stu_info` stuInfo\n" +
            "   FROM `student` WHERE `id` = #{id}")
    Student retrieveById(int id);

    /**
     * 添加一名学生信息
     * @param student 学生实体
     */
    @Insert("INSERT INTO `student`\n" +
            "   (`stu_name`, `stu_age`, `stu_gender`, `stu_info`)\n" +
            "   values\n" +
            "   (#{stuName}, #{stuAge}, #{stuGender}, #{stuInfo})")
    @Options(useGeneratedKeys = true, keyColumn = "id")
    void create(Student student);

    /**
     * 按照姓名模糊查询所有符合条件的学生
     * @param stuName 姓名的模糊查询
     * @return 所有符合条件的学生
     */
    @Select("SELECT `id`,\n" +
            "   `stu_name` stuName,\n" +
            "   `stu_age` stuAge,\n" +
            "   `stu_gender` stuGender,\n" +
            "   `stu_info` stuInfo\n" +
            "   FROM `student` WHERE `stu_name` like \"%\"#{stuName}\"%\"")
    List<Student> retrieveLikeName(String stuName);

    /**
     * 根据主键修改一条学生信息
     * @param student 学生实体
     */
    @Update("UPDATE `student` SET\n" +
            "   `stu_name` = #{stuName},\n" +
            "   `stu_age` = #{stuAge},\n" +
            "   `stu_gender` = #{stuGender},\n" +
            "   `stu_info` = #{stuInfo}\n" +
            "   WHERE `id` = #{id}")
    void updateById(Student student);

    /**
     * 根据主键删除学生
     * @param id 主键
     */
    @Delete("DELETE FROM `student` WHERE `id` = #{id}")
    void deleteById(int id);
}
```

> 使用Integer类型对应数据库中的int类型主键时要注意，数据库中主键需要设置为无符号，如果没有设置无符号则使用Long更为合适。

## 4. 测试

**源码：** junit测试
```java
/**
 * @author JoeZhou
 */
public class StudentTest {

    private SqlSession session;
    private StudentMapper mapper;

    @Before
    public void before() {
        String resource = "mybatis/mybatis-student.xml";
        SqlSessionFactory factory = MybatisTool.getSqlSessionFactory(resource);
        session = factory.openSession();
        mapper = session.getMapper(StudentMapper.class);
    }

    @After
    public void after() {
        session.close();
    }

    @Test
    public void retrieveById() {
        try {
            Student student = mapper.retrieveById(1);
            System.out.println(student);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Test
    public void create() {
        try {
            Student guangkun = new Student();
            guangkun.setStuName("谢广坤");
            guangkun.setStuAge("58");
            guangkun.setStuGender("male");
            guangkun.setStuInfo("广坤山货");
            mapper.create(guangkun);
            session.commit();
            System.out.println(guangkun);
        } catch (Exception e) {
            session.rollback();
            e.printStackTrace();
        }
    }

    @Test
    public void retrieveLikeName() {
        try {
            List<Student> students = mapper.retrieveLikeName("谢");
            System.out.println(students);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Test
    public void updateById() {
        try {
            Student liuNeng = new Student();
            liuNeng.setId(2);
            liuNeng.setStuName("刘能");
            liuNeng.setStuGender("male");
            liuNeng.setStuAge("68");
            liuNeng.setStuInfo("玉田花圃");
            mapper.updateById(liuNeng);
            session.commit();
            System.out.println(liuNeng);
        } catch (Exception e) {
            session.rollback();
            e.printStackTrace();
        }
    }

    @Test
    public void deleteById() {
        try {
            mapper.deleteById(28);
            session.commit();
        } catch (Exception e) {
            session.rollback();
            e.printStackTrace();
        }
    }
}
```



