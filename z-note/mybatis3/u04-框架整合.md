# 1. 整合准备

**流程：** 
- 添加依赖：
    - mybatis/mysql-connector-java/commons-dbcp2
    - spring-core/spring-beans/spring-aspects/spring-tx/spring-jdbc
    - spring-context/spring-context-support/spring-expression
    - log4j-core/log4j/slf4j-api/slf4j-log4j12
    - lombok/junit/spring-test/mybatis-spring
- 开发对应小狗表的小狗实体类。
- 开发mybatis主配文件：配置别名，SQL配置文件扫描和数据源交给spring做。

**源码：** /mybatis3/
- res: `pom.xml`
- res: `classpath:mybatis-sm.xml`
- src: `c.j.pojo.Dog`
- src: `c.j.pojo.Cat`

# 2. 原生DAO整合

**流程：**
- 开发SQL配置文件：编写CRUD语句块，不使用接口所以无需四大对应。
- 开发数据层接口和实现类：继承SM整合包中的 `SqlSessionDaoSupport`：
    - `getSqlSession()`：获取一个spring管理的session对象，不支持手动提交回滚和关闭。
- 开发spring主配文件并加载属性文件：
    - `<context:property-placeholder location="classpath:属性文件">`
- 在spring主配文件中IOC连接池 `o.a.c.d.BasicDataSource`：
    - 将驱动串等数据源信息DI给DBCP连接池的对应属性。
- 在spring主配文件中IOC会话工厂 `o.m.s.SqlSessionFactoryBean`：
    - 将mybatis的主配文件DI给 `configLocation` 属性。
    - 将连接池DI给 `dataSource` 属性。
    - 将SQL配置文件DI给 `mapperLocations` 属性。
- 在spring主配中IOC数据层实现类：
    - 将会话工厂DI给 `sqlSessionFactory` 属性（其父类的SET方法）。

**源码：** /mybatis3/
- res: `classpath:c.j.mapper.DogMapper.xml`
- res: `classpath:sprint/spring-dog.xml`
- src: `c.j.dao.DogDao`
- src: `c.j.dao.impl.DogDaoImpl`
- tst: `c.j.sm.DogTest`

# 3. 接口Mapper整合

**流程：**
- 开发SQL配置文件：编写CRUD语句块，需要和接口四大对应。
- 开发Mapper接口，建议与SQL配置文件同名同包。
- 开发spring主配文件并加载属性文件：
    - `<context:property-placeholder location="classpath:属性文件">`
- 在spring主配文件中IOC连接池 `o.a.c.d.BasicDataSource`：
    - 将驱动串等数据源信息DI给DBCP连接池的对应属性。
- 在spring主配文件中IOC会话工厂 `o.m.s.SqlSessionFactoryBean`：
    - 将mybatis的主配文件DI给 `configLocation` 属性。
    - 将连接池DI给 `dataSource` 属性。
    - 将SQL配置文件DI给 `mapperLocations` 属性，接口和配置文件同名同包时可省略。
- 在spring主配文件中IOC接口扫描类 `o.m.s.m.MapperFactoryBean`：
    - 将接口类全名DI给 `mapperInterface` 属性。
    - 将会话工厂DI给 `sqlSessionFactory` 属性。
- 在spring主配文件中IOC接口包扫描类 `o.m.s.m.MapperScannerConfigurer`：
    - 将接口所在包名DI给 `basePackage` 属性。
    - 包中所有接口的 `<bean>` 的id都默认为接口名首字母小写。
- 在spring主配文件中IOC单个接口 `o.m.s.m.MapperFactoryBean`：
    - 将接口全名DI给 `mapperInterface` 属性。
    - 将会话工厂DI给 `sqlSessionFactory` 属性。
    - 此方法与接口包扫描方法不共存。

**源码：** /mybatis3/
- res: `classpath:c.j.mapper.CatMapper.xml`
- res: `classpath:sprint/spring-cat.xml`
- src: `c.j.mapper.CatMapper`
- tst: `c.j.sm.CatTest`

# 4. 逆向工程

**概念：** mybatis逆向工程用于根据数据表生成对应的实体类，包含CRUD语句块的SQL配置文件，对应SQL配置文件的Mapper接口，mybatis主配置文件等，仅支持单表：
- 添加依赖：
    - mybatis/mybatis-generator-core/mysql-connector-java
- 开发逆向工程主配文件：放在工程的根目录下，不要放在classpath下：
    - 指定POJO文件在哪个包生成。
    - 指定Mapper配置文件在哪个包生成。
    - 指定Mapper接口在哪个包生成。
    - 指定要生成的数据库表。
    - 注意检查是否生成多遍SQL，手动删除重复代码。
- 开发主类并使用main方法运行逆向工程：
    - 若想要再次生成，需要先将之前生成的内容删除，否则会出现问题。

**源码：** /mybatis3-generator/
- res: `pom.xml`
- res: `generator.xml`
- src: `c.j.app.Generator`

## 4.1 插入API

**概念：** 
- `insert()` 在全部完整信息插入时调用。
- 使用 `insert()` 插入时，如果少设置一个字段，则该字段会被注入 `null`。
- 使用 `insert()` 实现部分字段的插入时不会使用动态SQL，性能低。

**源码：** junit测试
```java
@Test
public void insert(){
    User user = new User();
    user.setName("刘能");
    user.setAge(38);
    user.setGender("男");
    userMapper.insert(user);
}
```

## 7. 部分信息添加

**概念：** 
- `insertSelective()` 在部分信息插入(选择性插入)时调用。
- 使用 `insertSelective()` 插入时，如果少设置一个字段，该字段的注入过程会被忽略，但该字段的结果仍为 `null`。
- 使用 `insertSelective()` 实现部分字段的插入时且会使用动态SQL，性能高。

**源码：** junit测试
```java
@Test
public void insertSelective(){
    User user = new User();
    user.setName("赵四");
    userMapper.insertSelective(user);
}
```

## 8. 按照主键查询

**概念：** `selectByPrimaryKey()` 通过主键查询信息。

**源码：** junit测试
```java
@Test
public void selectByPrimaryKey(){
    int id = 7;
    User user = userMapper.selectByPrimaryKey(id);
    System.out.println(user);
}
```

## 9. 按照条件查询

**概念：** `selectByExample()` 通过条件查询信息，需要三个步骤：
- 创建条件对象：创建对应POJO的条件对象
    - `UserExample example = new UserExample()`。
- 设置条件对象：对条件对象设置条件
    - `example.createCriteria().条件方法()`。
- 使用条件对象：将设置好的条件对象作为查询参数
    - `mapper.selectByExample(example)`。

**源码：** junit测试
```java
/**按条件查询：查询姓赵的男性*/
@Test
public void selectByExample() {
    UserExample example = new UserExample();
    UserExample.Criteria criteria = example.createCriteria();
    criteria.andNameLike("赵%");
    criteria.andGenderEqualTo("男");
    List<User> users = userMapper.selectByExample(example);
    System.out.println(users);
}
```

## 10. 全查

**概念：** 调用 `selectByExample()` 的时候，传递一个未设置任何条件的条件对象，则视为全查。

**源码：** junit测试
```java
@Test
public void selectAll() {
    List<User> users = userMapper.selectByExample(new UserExample());
    System.out.println(users);
}
```

## 11. 查询数量

**概念：** 调用 `countByExample()` 可以按照条件查询符合条件的数据的条目数。

**源码：** junit测试
```java
/**查询id大于等于2的人数有多少*/
@Test
public void countByExample() {
    UserExample example = new UserExample();
    example.createCriteria()
            .andIdGreaterThanOrEqualTo(2);
    int count = userMapper.countByExample(example);
    System.out.println(count);
}
```

## 12. 查询排序

**概念：** 对条件对象调用 `setOrderByClause()` 可以对结果集进行排序。

**源码：** junit测试
```java
@Test
public void setOrderByClause() {
    UserExample example = new UserExample();
    example.setOrderByClause("age desc");
    List<User> users = userMapper.selectByExample(example);
    System.out.println(users);
}
```

## 13. 查询去重

**概念：** 对条件对象调用 `setDistinct()` 可以对结果集去重。

**源码：** junit测试
```java
@Test
public void setDistinct() {
    UserExample example = new UserExample();
    example.setDistinct(false);
    List<User> users = userMapper.selectByExample(example);
    System.out.println(users);
}
```

## 14. 查询or条件

**概念：** 对条件对象调用 `setOrderByClause()` 可以对结果集进行排序。

**源码：** junit测试
```java
/**找到年龄为null，或者年龄是10,20,30岁的用户*/
@Test
public void selectByOr(){
    List<Integer> ages = new ArrayList<>();
    ages.add(10);
    ages.add(20);
    ages.add(30);
    UserExample example = new UserExample();
    example.or().andAgeIsNull();
    example.or().andAgeIn(ages);
    List<User> users = userMapper.selectByExample(example);
    System.out.println(users);
}
```

## 15. 按主键修改全部信息

**概念：** 
- `updateByPrimaryKey()` 在全部完整信息修改时调用。
- 使用 `updateByPrimaryKey()` 修改时，如果少设置一个字段，则该字段会被注入 `null`。

**源码：** junit测试
```java
@Test
public void updateByPrimaryKey(){
    User user = new User();
    user.setId(1);
    user.setName("赵四儿");
    user.setGender("男");
    userMapper.updateByPrimaryKey(user);
}
```

## 16. 按主键修改部分信息

**概念：** 
- `updateByPrimaryKeySelective()` 在部分信息修改(选择性修改)时调用。
- 使用 `updateByPrimaryKeySelective()` 修改时，如果少设置一个字段，该字段的修改过程会被忽略，即保留原值。

**源码：** junit测试
```java
@Test
public void updateByPrimaryKeySelective() {
    User user = new User();
    user.setId(1);
    user.setName("赵四");
    userMapper.updateByPrimaryKeySelective(user);
}
```

## 17. 按条件修改全部信息

**概念：** 
- `updateByExample()` 在全部完整信息修改时调用。
- 使用 `updateByExample()` 修改时，如果少设置一个字段，则该字段会被注入 `null`。

**源码：** junit测试
```java
@Test
public void updateByExample() {
    UserExample example = new UserExample();
    example.createCriteria()
            .andNameEqualTo("赵四");
    User user = new User();
    user.setName("赵老四");
    user.setAge(88);
    userMapper.updateByExampleSelective(user, example);
}
```

## 18. 按条件修改部分信息

**概念：** 
- `updateByExampleSelective()` 在部分信息修改(选择性修改)时调用。
- 使用 `updateByExampleSelective()` 修改时，如果少设置一个字段，该字段的修改过程会被忽略，即保留原值。

**源码：** junit测试
```java
@Test
public void updateByExampleSelective() {
    UserExample example = new UserExample();
    example.createCriteria()
            .andNameEqualTo("赵老四");
    User user = new User();
    user.setName("赵国强");
    userMapper.updateByExampleSelective(user, example);
}
```

## 19. 按主键删除

**概念：** `deleteByPrimaryKey()` 按照主键删除信息。

**源码：** junit测试
```java
@Test
public void deleteByPrimaryKey(){
    int id = 1;
    userMapper.deleteByPrimaryKey(id);
}
```

## 20. 按条件删除

**概念：** `deleteByExample()` 按照条件删除。


**源码：** junit测试
```java
@Test
public void deleteByExample() {
    UserExample example = new UserExample();
    example.or().andAgeIsNull();
    example.or().andAgeBetween(18, 40);
    userMapper.deleteByExample(example);
}
```
