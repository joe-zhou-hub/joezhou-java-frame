# 1. 静态查询

**需求：** 找到所有名中含"王"的男用户。

**源码：** /mybatis3/
- res: `classpath:mybatis-dynamic.xml`
- res: `classpath:com/joezhou/mapper/UserMapper.xml`
- src: `c.j.pojo.User`
- src: `c.j.mapper.UserMapper`
- tst: `c.j.dynamic.UserTest.findLikeNameAndGender()`

# 2. 动态查询if

**需求：** 找到所有名中含"王"的男用户，若姓名为null，则按性别精准查询，若性别为null，则按姓名模糊查询：
- `<if test='OGNL表达式'>`：用于SQL语句块内的条件判断，表达式建议用单引号，以免冲突表达式中的字符串。

**源码：** /mybatis3/
- res: `classpath:mybatis-dynamic.xml`
- res: `classpath:com/joezhou/mapper/UserMapper.xml`
- src: `c.j.mapper.UserMapper`
- tst: `c.j.dynamic.UserTest.findLikeNameAndGenderByIf()`

# 3. 动态查询where

**需求：** 找到所有名中含"王"的男用户，若姓名为null，则按性别精准查询，若性别为null，则按姓名模糊查询，
若姓名和性别均不为null，则按姓名模糊且按性别精准查询，若姓名和性别都为null，全查：
- `<where>` 标签可以自动生成 `WHERE`，且自动的删除第一个 `AND`。 
- `<where>` 标签中如果是空的，不会生成 `WHERE`。
- 上面的功能，可以使用 `<trim>` 来完成。
- `prefix`：添加文字前缀。
- `prefixOverrides` 中填写的是一个文字管道，负责移除指定的内容，注意 `AND` 和 `OR` 后面都有一个空格。

**源码：** /mybatis3/
- res: `classpath:mybatis-dynamic.xml`
- res: `classpath:com/joezhou/mapper/UserMapper.xml`
- src: `c.j.mapper.UserMapper`
- tst: `c.j.dynamic.UserTest.findLikeNameAndGenderByWhere()`
- tst: `c.j.dynamic.UserTest.findLikeNameAndGenderByTrim()`

**配置：** StudentMapper.xml 中修改
```xml
<select id="retrieveByNameAndGender" resultMap="studentMap">
    SELECT <include refid="cols"/> FROM `student`
    <trim prefix="WHERE" prefixOverrides="AND |OR ">
        <if test='stuName != null'>
            AND `stu_name` LIKE "%"#{stuName}"%"
        </if>
        <if test='stuGender != null'>
            AND `stu_gender` = #{stuGender}
        </if>
    </trim>
</select>
```

# 2. choose

**需求：** 在 `id` 一定不为null的前提下，找到某些符合要求的人：
- 如果姓名不为null，按照姓名模糊查询。
- 如果姓名为null，但性别不为null，则按照性别精准查询。
- 如果姓名和性别都为null，则按照 `id` 精准查询。

# 2. Mapper配置

**概念：** 
- `<choose>` 标签组合 `<when>` 和 `<otherwise>` 可以进行某些SQL语句是否拼接的判断。
- `<when>` 中使用 `test` 来进行条件判断，`test` 中使用的是OGNL表达式。

**配置：** StudentMapper.xml 中修改
```xml
<resultMap id="studentMap" type="student">
    <result column="stu_name" property="stuName" javaType="string" jdbcType="VARCHAR"/>
    <result column="stu_age" property="stuAge" jdbcType="VARCHAR"/>
    <result column="stu_gender" property="stuGender"/>
    <result column="stu_info" property="stuInfo"/>
</resultMap>

<sql id="cols">
    `id`, `stu_name`, `stu_age`, `stu_gender`, `stu_info`
</sql>

<select id="retrieveByNameAndGender" resultMap="studentMap">
    SELECT <include refid="cols"/> FROM `student`
    <where>
        <choose>
            <when test='stuName != null'>
                AND `stu_name` LIKE "%"#{stuName}"%"
            </when>
            <when test='stuGender != null'>
                AND `stu_gender` = #{stuGender}
            </when>
            <otherwise>
                AND `id` = #{id}
            </otherwise>
        </choose>
    </where>
</select>
```

# 3. Mapper接口

**源码：** StudentMapper.java
```java
/**
 * 在 `id` 一定不为null的前提下，找到某些符合要求的人。
 *
 * @param student 带条件的实体
 * @return 满足条件的用户
 * */
List<Student> retrieveByNameAndGender(Student student);
```

# 4. 测试

**源码：** junit测试
```java
@Test
public void retrieveByNameAndGender() {
    Student student01 = new Student();
    student01.setId(1);
    student01.setStuName("王");

    Student student02 = new Student();
    student02.setId(1);
    student02.setStuGender("male");

    Student student03 = new Student();
    student03.setId(1);

    List<Student> students01 = mapper.retrieveByNameAndGender(student01);
    List<Student> students02 = mapper.retrieveByNameAndGender(student02);
    List<Student> students03 = mapper.retrieveByNameAndGender(student03);

    System.out.println(students01);
    System.out.println(students02);
    System.out.println(students03);
}
```

# 1. 需求

**需求：** 找到编号为3和4和6的用户。

# 2. Mapper配置

**概念：** `<foreach>` 标签负责SQL语句的循环拼接。
- `collection`：负责绑定你传递进来的集合或者数组类型的参数，底层会将它们封装在一个 `Map` 中：
    - 如果参数是一个数组：`collection="array"`。
    - 如果参数是一个列表：`collection="list"`。
    - 如果参数中存在多个数组或列表，可以把它们封装到一个 `Map` 中，然后 `collection="Map中的key"`。
- `items`：是循环中间变量。
- `open` 和 `close`：是循环开始和结束时拼接的字符串。
- `separator`：是拼接分割符，它很智能，不会添加多余的分隔符。

**配置：** StudentMapper.xml 中添加
```xml
<resultMap id="studentMap" type="student">
    <result column="stu_name" property="stuName" javaType="string" jdbcType="VARCHAR"/>
    <result column="stu_age" property="stuAge" jdbcType="VARCHAR"/>
    <result column="stu_gender" property="stuGender"/>
    <result column="stu_info" property="stuInfo"/>
</resultMap>

<sql id="cols">
    `id`, `stu_name`, `stu_age`, `stu_gender`, `stu_info`
</sql>

<select id="retrieveByIds" resultMap="studentMap">
    SELECT <include refid="cols"/> FROM `student`
    <where>
        <foreach collection='array' 
            item='e' open=' id in(' close=')' separator=','>
            
            ${e}
        </foreach>
    </where>
</select>
```

```!
直接使用 `in` 的写法有注入漏洞问题，不要使用！
```

# 3. Mapper接口

**源码：** StudentMapper.java
```java
/**
 * 根据主键数组批量查询用户
 *
 * @param ids 批量主键
 * @return 满足条件的用户
 */
List<Student> retrieveByIds(int[] ids);
```

# 4. 测试

**源码：** junit测试
```java
private SqlSession session;
private StudentMapper mapper;

@Before
public void before() {
    String resource = "mybatis/mybatis-student.xml";
    SqlSessionFactory factory = MybatisTool.getSqlSessionFactory(resource);
    session = factory.openSession();
    mapper = session.getMapper(StudentMapper.class);
}

@After
public void after() {
    session.close();
}

@Test
public void retrieveByIds() {
    int[] ids = {2, 3, 4};
    List<Student> students = mapper.retrieveByIds(ids);
    System.out.println(students);
}
```
# 1. 动态修改set

## 1.1 需求

**需求：** 在修改操作中，如果某个字段设置为null，则不进行修改。

## 1.2 Mapper配置

**概念：** `<set>` 标签负责SQL语句的动态修改，可以自动删除最后一个逗号。

**配置：** StudentMapper.xml 中添加
```xml
<update id="updateById">
    UPDATE `student`
    <set>
        <if test='stuName != null'>`stu_name` = #{stuName},</if>
        <if test='stuAge != null'>`stu_age` = #{stuAge},</if>
        <if test='stuGender != null'>`stu_gender` = #{stuGender},</if>
    </set>
    <where>
        id = #{id}
    </where>
</update>
```

## 1.3 Mapper接口

**源码：** StudentMapper.java
```java
/**
 * 根据主键动态修改学生信息
 * @param student 学生实体
 */
void updateById(Student student);
```

## 1.4 测试

**源码：** junit测试
```java
private SqlSession session;
private StudentMapper mapper;

@Before
public void before() {
    String resource = "mybatis/mybatis-student.xml";
    SqlSessionFactory factory = MybatisTool.getSqlSessionFactory(resource);
    session = factory.openSession();
    mapper = session.getMapper(StudentMapper.class);
}

@After
public void after() {
    session.close();
}

@Test
public void updateById() {
    Student student = new Student();
    student.setId(1);
    student.setStuName("奥特曼");
    try {
        mapper.updateById(student);
        session.commit();
    } catch (Exception e) {
        e.printStackTrace();
    } finally {
        session.close();
    }
}
```

# 2. 动态修改trim

## 2.1 需求

**需求：** 在修改操作中，如果某个字段设置为null，则不进行修改。

## 2.2 Mapper配置

**概念：** 上面的功能，可以使用 `<trim>` 来完成。
- `prefix`：添加文字前缀。
- `prefixOverrides` 中填写的是一个文字管道，负责移除指定的内容。

**配置：** StudentMapper.xml 中添加
```xml
<update id="updateById">
    UPDATE `student`
    <trim prefix="SET" prefixOverrides=",">
        <if test='stuName != null'>, `stu_name` = #{stuName}</if>
        <if test='stuAge != null'>, `stu_age` = #{stuAge}</if>
        <if test='stuGender != null'>, `stu_gender` = #{stuGender}</if>
        <where>
            id = #{id}
        </where>
    </trim>
</update>
```

> Mapper接口和测试同上。

# 1. 需求

**需求：** 找到所有名中含"王"的男同学。

# 2. Mapper配置

**配置：** StudentMapper.xml 中修改
```xml
<select id="retrieveByNameAndGender" resultMap="studentMap">
    SELECT <include refid="cols"/> FROM `student`
    <where>
        <if test='stuName != null'>
            AND `stu_name` LIKE "%"#{stuName}"%"
        </if>
        <if test='stuGender != null'>
            AND `stu_gender` = #{stuGender}
        </if>
    </where>
</select>
```

# 3. Mapper接口

**概念：** 如果接口方法的参数是多个，则需要使用 `@Param` 进行分别标注。

**源码：** StudentMapper.java
```java
/**
 * 找到所有名中含"王"的男同学
 *
 * @param stuName   姓名
 * @param stuGender 性别
 * @return 满足条件的用户
 */
List<Student> retrieveByNameAndGender(
        @Param("stuName") String stuName,
        @Param("stuGender") String stuGender);
```

# 4. 测试

**源码：** junit测试
```java
@Test
public void retrieveByNameAndGender() {
    String stuName = "王";
    String stuGender = "male";
    List<Student> students = mapper.retrieveByNameAndGender(stuName, stuGender);
    System.out.println(students);
}
```

# 1. 内置参数

**概念：** 如果客户没有调用接口方法，而是直接通过另一个SQL块直接调用了这个SQL块，则这个SQL块中是无法解析 `@Param` 中定义的参数的，所以我们还有另一种方法来获取参数，就是使用  `_parameter`，它是MyBatis的内置参数，它代表整个参数集。

# 2. 一个简单参数

**概念：** 如果接口方法传递过来的是一个简单参数，则 `_parameter` 代表这个简单参数：
- 如果没设置 `@Param`，则 `#{}` 填写任何值均可获取这个参数。
- 如果设置了 `@Param("a")`，则只有 `#{a}` 或 `#{param1}` 可以获取这个参数。

## 2.1 Mapper配置

**配置：** StudentMapper.xml
```xml
<select id="test01" resultMap="studentMap">
    SELECT <include refid="cols"/> FROM `student`
    <where>
        <if test='_parameter != null'>
            AND `stu_name` like "%"#{param1}"%"
        </if>
    </where>
</select>
```

## 2.2 Mapper接口

**源码：** StudentMapper.java
```java
/**
 * 根据姓名模糊查询学生信息
 *
 * @param stuName 姓名
 * @return 符合条件的学生信息
 */
List<Student> test01(String stuName);
```

## 2.3 测试

**源码：** junit测试
```java
@Test
public void test01() {
    String stuName = "王";
    List<Student> students = mapper.test01(stuName);
    System.out.println(students);
}
```

# 3. 两个简单参数

**概念：** 如果接口方法传递过来的是两个简单参数，则 `_parameter` 代表这两个简单参数的集合：
- 如果没设置 `@Param`：
    - `_parameter.get("param1")` 或 `_parameter.get("arg0")` 表示第一个参数。
    - `_parameter.get("param2")` 或 `_parameter.get("arg1")` 表示第二个参数。
    - `#{param1}` 或 `#{arg0}` 可以获取第一个参数。
    - `#{param2}` 或 `#{arg1}` 可以获取第二个参数。
- 如果设置了 `@Param("a")` 和 `@Param("b")`：
    - `_parameter.get("param1")` 或 `_parameter.get("a")` 表示第一个参数。
    - `_parameter.get("param2")` 或 `_parameter.get("b")` 表示第二个参数。
    - `#{param1}` 或 `#{a}` 可以获取第一个参数。
    - `#{param2}` 或 `#{b}` 可以获取第二个参数

## 3.1 Mapper配置

**配置：** StudentMapper.xml
```xml
<select id="test02" resultMap="studentMap">
    SELECT <include refid="cols"/> FROM `student`
    <where>
        <if test='_parameter.get("param1") != null'>
            AND `stu_name` like "%"#{param1}"%"
        </if>
        <if test='_parameter.get("param2") != null'>
            AND `stu_gender` = #{param2}
        </if>
    </where>
</select>
```

## 3.2 Mapper接口

**源码：** StudentMapper.java
```java
/**
 * 根据姓名模糊和性别精准查询学生信息
 *
 * @param stuName 姓名
 * @param stuGender  性别
 * @return 符合条件的学生信息
 */
List<Student> test02(String stuName, String stuGender);
```

## 3.3 测试

**源码：** junit测试
```java
@Test
public void test02() {
    String stuName = "王";
    String stuGender = "male";
    List<Student> students = mapper.test02(stuName, stuGender);
    System.out.println(students);
}
```

# 4. 一个POJO参数

**概念：** 如果接口方法传递过来的是一个POJO参数，则 `_parameter` 代表这个POJO参数：
- 如果没设置 `@Param`：
    - `_parameter.stuName` 表示POJO中的 `stuName` 属性。
    - `#{stuName}` 可以获取POJO中的 `stuName` 属性。
- 如果设置了 `@Param("a")`：
    - `_parameter.a` 或 `_parameter.param1` 表示这个POJO参数。
    - `_parameter.a.stuName` 或 `_parameter.param1.stuName` 表示POJO中的 `stuName` 属性。
    - `#{a.stuName}` 或 `#{param1.stuName}` 可以获取POJO中的 `stuName` 属性。

## 4.1 Mapper配置

**配置：** StudentMapper.xml
```xml
<select id="test03" resultMap="studentMap">
    SELECT <include refid="cols"/> FROM `student`
    <where>
        <if test='_parameter.param1 != null'>
            <if test='_parameter.param1.stuName != null'>
                AND `stu_name` like "%"#{param1.stuName}"%"
            </if>
            <if test='_parameter.param1.stuGender != null'>
                AND `stu_gender` = #{param1.stuGender}
            </if>
        </if>
    </where>
</select>
```

## 4.2 Mapper接口

**源码：** StudentMapper.java
```java
/**
 * 根据学生实体中的姓名和性别查询学生信息
 *
 * @param student 学生实体
 * @return 符合条件的学生信息
 */
List<Student> test03(Student student);
```

## 4.3 测试

**源码：** junit测试
```java
@Test
public void test03() {
    Student student = new Student();
    student.setStuName("王");
    student.setStuGender("male");
    List<Student> students = mapper.test03(student);
    System.out.println(students);
}
```

