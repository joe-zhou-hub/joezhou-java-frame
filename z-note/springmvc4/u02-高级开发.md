# 1. 类型转换器

**概念：** 处理器适配器中可配置自定义类型转换器，用于将请求参数类型转成自定义类型：
- 开发转换器类：实现 `o.s.c.c.c.Converter<A, B>` 接口并重写 `convert()`：
    - 该转换器仅在动作方法使用B类型变量接收A类型请求参数时生效。
- 配置转换器类：在springmvc主配文件中：
    - 管理 `o.s.f.s.FormattingConversionServiceFactoryBean` 并注入 `converters=转换器类全名`。
    - 使用 `<mvc:annotation-driven />` 的 `conversion-service` 引用转换器。

**源码：** /springmvc4/
- res: `spring/springmvc.xml`
- src: `c.j.converter.StringToDateConverter`
- src: `c.j.controller.ConverterController`
- psm: `/api/converter/string-to-date`

# 3. 配置转换器类


# 1. 使用注解格式化参数

**概念：** 
- 有时候需要进行格式化操作的日期、数字等类型属性在某个POJO类中，除了使用自定义转化器之外还可以使用spring提供的转换注解。
- 使用格式化注解有两个条件：
    - 在SpringMVC的核心配置文件中使用 `<mvc:annotation-driven/>` 
    - 配置 `FormattingConversionServiceFactoryBean` 的 `<bean>`，`<bean>` 中无需配置和指定自己的转换器类。
- "格式化注解"和"自定义转换器类"如果同时存在，则会以"自定义转换器类"为主。
- 如果你仍想同时指定自己的"转换器类"，则也可以继续在 `FormattingConversionServiceFactoryBean` 的 `<bean>` 中使用 `<property name="converters">` 等子标签指定。

**配置：** springmvc.xml
```xml
<mvc:annotation-driven/>

<bean class="org.springframework.format.support.FormattingConversionServiceFactoryBean"/>
```

# 2. 注解添加在动作类参数前

**概念：** `@DateTimeFormat` 可以将日期格式的数据进行格式化。
- 将 `@DateTimeFormat(pattern = "yyyy-MM-dd")` 直接添加在动作类方法的参数前。
- 还可以使用 `@NumberFormat` 指定sal属性的输入格式必须为 `#,###`（其中#代表数字）。
- 如果输入的日期格式不符合 `yyyy-MM-dd` 格式，则页面会报400错误。

**源码：** DateTimeFormatController.java
```java
/**
 * @author JoeZhou
 */
@Controller
@RequestMapping("date")
public class DateTimeFormatController {

    @ResponseBody
    @RequestMapping("formatAnn.action")
    public String formatAnn(@DateTimeFormat(pattern = "yyyy-MM-dd") Date birth, String name) {
        System.out.println(birth);
        System.out.println(name);
        return "ok";
    }
}
```

> 测试接口：date/formatAnn.action?birth=2001-01-01&name=zhaosi

# 3. 注解添加在POJO属性上

**概念：** 如果Date类型的属性在一个POJO中，也可以在POJO中对其添加注解。

**源码：** Emp.java
```java
/**
 * @author JoeZhou
 */
@Data
public class Emp implements Serializable {
	
    @DateTimeFormat(pattern = "yyyy-MM-dd")
    private Date hiredate;
}
```

**源码：** DateTimeFormatController.java 中添加
```java
@ResponseBody
@RequestMapping("formatPojo.action")
public String formatPojo(Emp emp) {
    System.out.println(emp.getHiredate());
    return "ok";
}
```

> 测试接口：date/formatPojo.action?hiredate=1978-08-08

# 4. 查看格式化异常信息

**概念：** 
- 使用注解 `@DateTimeFormat` 时，如果页面端输入的日期格式不符合 `yyyy-MM-dd` 格式，则页面会报400错误，但是控制台没有错误提示！如果控制台想看异常信息，可以利用 `BindingResult` 类型的参数，它包含了格式化数据失败时的异常信息。
- `BindingResult` 中存的是它前一个参数的异常信息，所以位置必须紧随 `Emp emp` 之后，位置是固定。
    - `result.hasErrors()`：判断是否有错误。
    - `result.getErrorCount()`：返回错误的个数。
    - `result.getAllErrors()`：获取所有的错误集合。
    - `e.getObjectName()`：获取爆发了异常的那么对象。
    - `e.getFieldName()`：获取了爆发异常的那个属性。
    - `e.getDefaultMessage()`：获取具体的异常信息。

**源码：** DateTimeFormatController.java 中添加
```java
@ResponseBody
@RequestMapping("formatException.action")
public String formatException(Emp emp, BindingResult result) {

    if (result.hasErrors()) {
        System.out.println("爆发了" + result.getErrorCount() + "个异常！");
        for (ObjectError e : result.getAllErrors()) {
            System.out.println("爆发异常的对象是：" + e.getObjectName());
            System.out.println("具体异常的内容为：" + e.getDefaultMessage());
        }
    }
    return "ok";
}
```

> 测试接口：date/formatException.action?hiredate=1999/11/11

# 1. 数据校验

**概念：** 
- 除了使用JS、正则表达式以外，还可以使用 `JSR303-Bean Validation`（简称 `JSR303`）来实现数据的校验。
- `JSR303` 可以帮你校验数据是否正确，但不能主动阻止程序继续向下运行，需要自己手动处理。

# 2. JSR303数据校验注解

注解 | 简介
-|-
`@Null`        | 被注释的元素必须为 null。
`@NotNull`     | 被注释的元素必须不为 null。
`@AssertTrue`  | 被注释的元素必须为 true。
`@AssertFalse` | 被注释的元素必须为 false。
`@Min(value)`  | 被注释的元素必须是一个整数，其值必须大于或等于value。
`@Max(value)`  | 被注释的元素必须是一个整数，其值必须小于或等于value。
`@DecimalMin(value)` | 被注释的元素必须是一个浮点数，其值必须大于或等于value。
`@DecimalMax(value)` | 被注释的元素必须是一个浮点数，其值必须小于或等于value。
`@Size(max, min)` | 被注释的元素的取值范围必须是介于min和max之间。
`@Digits (integer, fraction)` | 被注释的元素必须是一个数字，其值必须在可接受的范围内。
`@Past`   | 被注释的元素必须是一个过去的日期。
`@Future` | 被注释的元素必须是一个将来的日期。
`@Pattern(value)` | 被注释的元素必须符合指定的正则表达式。

# 3. Hibernate Validator数据校验注解

**概念：** `Hibernate Validator` 是 `JSR303` 的扩展，提供了 `JSR303` 中所有内置的注解，以及自身扩展的4个注解。

注解 | 简介
-|-
`@Email`    | 被注释的元素值必须是合法的电子邮箱地址。
`@Length`   | 被注释的字符串的长度必须在指定的范围内。
`@NotEmpty` | 被注释的String类，Collection、Map、数组，是不能为null或者长度为0的。
`@Range`    | 被注释的元素必须在合适的范围内。

# 4. 添加依赖

**配置：** pom.xml
```xml
<dependency>
    <groupId>org.hibernate.validator</groupId>
    <artifactId>hibernate-validator</artifactId>
    <version>6.0.13.Final</version>
</dependency>
```

# 5. 核心配置

**概念：** 
- Spring提供了一个 `LocalValidatorFactoryBean` 类，这个类既实现了Spring的校验接口，也实现了 `JSR303` 的校验接口。
- `<mvc:annotation-driven />` 会自动给Spring容器装配一个 `LocalValidatorFactoryBean`，因此只需要在SpringMVC的核心配置文件中配置 `<mvc:annotation-driven />` 即可。

**配置：** springmvc.xml
```xml
<mvc:annotation-driven/>
```

# 6. 实体类

**概念：** 
- 同一个属性可以挂载多个注解验证，验证优先级是从上到小。
- 注解的包：`javax.validation.constraints`。

**源码：** Teacher.java
```java
/**
 * @author JoeZhou
 */
@Data
public class Teacher {

    @NotNull
    @Email
    private String email;

    @NotNull
    @Past
    @DateTimeFormat(pattern = "yyyy-MM-dd")
    private Date birth;
} 
```

# 7. 动作类

**概念：** 
- 在请求处理方法对应的实体类参数前，增加 `@Valid` 注解。
- SpringMVC会对标有 `@Valid` 注解的实体类参数进行校验，并且可以通过 `BindingResult` 类型的参数来存储校验失败时的信息，如果输入的数据不符合要求，就会在控制台得到校验失败的信息。
- 错误信息是 `JSR303` 或者 `Hibernate Validator` 框架提供的，无需开发人员编写。


**源码：** JsrController.java
```java
/**
 * @author JoeZhou
 */
@RequestMapping("jsr")
@Controller
public class JsrController {

    @ResponseBody
    @RequestMapping("validation.action")
    public String validation(@Valid Teacher teacher, BindingResult result) {
        if (result.hasErrors()) {
            System.out.println("爆发了" + result.getErrorCount() + "个异常！");
            for (ObjectError e : result.getAllErrors()) {
                System.out.println("爆发异常的对象是：" + e.getObjectName());
                System.out.println("具体异常的内容为：" + e.getDefaultMessage());
            }
        }
        System.out.println(teacher);
        return "ok";
    }
}
```

> 测试接口：jsr/validation.action?email=yy06200210@163.com&birth=2002-11-11

