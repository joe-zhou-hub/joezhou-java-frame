# 1. 类型转换器

**概念：** 处理器适配器中可配置自定义类型转换器，用于将请求参数类型转成自定义类型：
- 开发转换器类：实现 `o.s.c.c.c.Converter<A, B>` 接口并重写 `convert()`：
    - 该转换器仅在动作方法使用B类型变量接收A类型请求参数时生效。
- 配置转换器类：主配文件中管理 `o.s.f.s.FormattingConversionServiceFactoryBean`：
    - 注入 `converters`：使用 `<set>` + `<bean>` 注入1或N个转换器类全名。
    - 使用 `<mvc:annotation-driven />` 的 `conversion-service` 引用转换器类。
- 使用转换注解：主配文件中管理 `o.s.f.s.FormattingConversionServiceFactoryBean`：
    - 无需注入 `converters`，否则转换注解失效，仍使用转换器类方式。
    - 使用 `@DateTimeFormat(pattern="")` 标记动作方法参数或实体类属性。
    - 转换注解的异常信息存放在 `BindingResult` 参数中，其位置必须紧跟爆发异常的那个实体类参数。

**源码：** /springmvc4/
- res: `spring/springmvc.xml`
- src: `c.j.converter.StringToDateConverter`
- src: `c.j.controller.ConverterController`
- psm: `/api/converter/string-to-date`
- psm: `/api/converter/date-time-format`

# 4. 查看格式化异常信息

**概念：** 


**源码：** DateTimeFormatController.java 中添加
```java
@ResponseBody
@RequestMapping("formatException.action")
public String formatException(Emp emp, BindingResult result) {

    
    return "ok";
}
```

> 测试接口：date/formatException.action?hiredate=1999/11/11

# 2. 数据校验

**概念：** 
- 除了使用JS、正则表达式以外，还可以使用 `JSR303-Bean Validation`（简称 `JSR303`）来实现数据的校验。
- `JSR303` 可以帮你校验数据是否正确，但不能主动阻止程序继续向下运行，需要自己手动处理。

# 2. JSR303数据校验注解

注解 | 简介
-|-
`@Null`        | 被注释的元素必须为 null。
`@NotNull`     | 被注释的元素必须不为 null。
`@AssertTrue`  | 被注释的元素必须为 true。
`@AssertFalse` | 被注释的元素必须为 false。
`@Min(value)`  | 被注释的元素必须是一个整数，其值必须大于或等于value。
`@Max(value)`  | 被注释的元素必须是一个整数，其值必须小于或等于value。
`@DecimalMin(value)` | 被注释的元素必须是一个浮点数，其值必须大于或等于value。
`@DecimalMax(value)` | 被注释的元素必须是一个浮点数，其值必须小于或等于value。
`@Size(max, min)` | 被注释的元素的取值范围必须是介于min和max之间。
`@Digits (integer, fraction)` | 被注释的元素必须是一个数字，其值必须在可接受的范围内。
`@Past`   | 被注释的元素必须是一个过去的日期。
`@Future` | 被注释的元素必须是一个将来的日期。
`@Pattern(value)` | 被注释的元素必须符合指定的正则表达式。

# 3. Hibernate Validator数据校验注解

**概念：** `Hibernate Validator` 是 `JSR303` 的扩展，提供了 `JSR303` 中所有内置的注解，以及自身扩展的4个注解。

注解 | 简介
-|-
`@Email`    | 被注释的元素值必须是合法的电子邮箱地址。
`@Length`   | 被注释的字符串的长度必须在指定的范围内。
`@NotEmpty` | 被注释的String类，Collection、Map、数组，是不能为null或者长度为0的。
`@Range`    | 被注释的元素必须在合适的范围内。

# 4. 添加依赖

**配置：** pom.xml
```xml
<dependency>
    <groupId>org.hibernate.validator</groupId>
    <artifactId>hibernate-validator</artifactId>
    <version>6.0.13.Final</version>
</dependency>
```

# 5. 核心配置

**概念：** 
- Spring提供了一个 `LocalValidatorFactoryBean` 类，这个类既实现了Spring的校验接口，也实现了 `JSR303` 的校验接口。
- `<mvc:annotation-driven />` 会自动给Spring容器装配一个 `LocalValidatorFactoryBean`，因此只需要在SpringMVC的核心配置文件中配置 `<mvc:annotation-driven />` 即可。

**配置：** springmvc.xml
```xml
<mvc:annotation-driven/>
```

# 6. 实体类

**概念：** 
- 同一个属性可以挂载多个注解验证，验证优先级是从上到小。
- 注解的包：`javax.validation.constraints`。

**源码：** Teacher.java
```java
/**
 * @author JoeZhou
 */
@Data
public class Teacher {

    @NotNull
    @Email
    private String email;

    @NotNull
    @Past
    @DateTimeFormat(pattern = "yyyy-MM-dd")
    private Date birth;
} 
```

# 7. 动作类

**概念：** 
- 在请求处理方法对应的实体类参数前，增加 `@Valid` 注解。
- SpringMVC会对标有 `@Valid` 注解的实体类参数进行校验，并且可以通过 `BindingResult` 类型的参数来存储校验失败时的信息，如果输入的数据不符合要求，就会在控制台得到校验失败的信息。
- 错误信息是 `JSR303` 或者 `Hibernate Validator` 框架提供的，无需开发人员编写。


**源码：** JsrController.java
```java
/**
 * @author JoeZhou
 */
@RequestMapping("jsr")
@Controller
public class JsrController {

    @ResponseBody
    @RequestMapping("validation.action")
    public String validation(@Valid Teacher teacher, BindingResult result) {
        if (result.hasErrors()) {
            System.out.println("爆发了" + result.getErrorCount() + "个异常！");
            for (ObjectError e : result.getAllErrors()) {
                System.out.println("爆发异常的对象是：" + e.getObjectName());
                System.out.println("具体异常的内容为：" + e.getDefaultMessage());
            }
        }
        System.out.println(teacher);
        return "ok";
    }
}
```

> 测试接口：jsr/validation.action?email=yy06200210@163.com&birth=2002-11-11

