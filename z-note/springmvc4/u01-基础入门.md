# 1. 概念入门

**概念：** springmvc是spring框架的控制层技术，核心是前端控制器 `DispatcherServlet`，负责管理和调用其它组件以处理用户的http请求，降低组件间的耦合度：
- 当浏览器请求符合前端控制器规则时，WEB服务器会将其转交给前端控制器。
- 前端控制器调用处理器映射器 `HandlerMapping`：
    - 根据请求URL找到某自定义Handler，将其和拦截器（若有）封装成执行链并返回。
- 前端控制器调用处理器适配器 `HandlerAdapter`：
    - 执行执行链中拦截器和Handler并返回一个ModelAndView对象。
- 前端控制器调用视图解析器 `ViewResolver`：
    - 将ModelAndView中的逻辑视图名拼接前后缀后解析为物理视图名，并返回View对象。 
- 前端控制器根据View组装HTML页面响应给浏览器，浏览器渲染页面:
    - 渲染：浏览器解析HTML，构建DOM树，整合CSS和JS，布局，绘制等过程。

> z-image/一个核心三个组件.png

## 1.1 配通

**流程：** 添加 `spring-webmvc` 依赖：
- 在web.xml中配置前端控制器类 `o.s.w.s.DispatcherServlet`：
    - 使用 `<init-param>` 注入 `contextConfigLocation=springmvc主配文件`：
        - 默认加载 `/WEB-INF/配对名-servlet.xml`。
    - 使用 `<url-pattern>` 设置前端控制器拦截规则，可设置多个：
        - `*.do/.action`：仅拦截以.do或.action结尾的请求。
        - `/`：拦截除JSP外的一切请求，静态资源请求需在web.xml中手动放行。
        - `/*`：拦截包括JSP的一切请求，静态资源请求需在web.xml中手动放行，不建议。
- 开发springmvc主配文件：
    - 使用 `<mvc:annotation-driven />` 驱动管理处理器映射器类和处理器适配器类。
    - 使用 `<context:component-scan />` 包扫描 `@Component`。
    - 管理视图解析器类：`o.s.w.s.v.InternalResourceViewResolver`：
        - 注入 `prifix` 以配置响应路径前缀，可选。
        - 注入 `suffix` 以配置响应路径后缀，可选。
- 开发动作类：添加 `@Controller`。
- 开发动作方法：添加 `@RequestMapping` 设置方法路由，可省略两端 `/` 和 `.do` 后缀：
    - 修饰符必须 `public`，方法名随意。
    - 若返回字符串，会自动拼接视图解析器前后缀并执行请求转发。
- 测试：请求URL中不可省略 `.do` 后缀（若有）。

**源码：** /springmvc4/
- res: `pom.xml`
- res: `WEB-INF/web.xml`
- res: `classpath:spring/springmvc.xml`
- src: `c.j.controller.StartController`
- web: `webapp/view/success.html`
- psm: `/api/start`

## 1.2 @RequestMapping

**概念：** 注解式处理器映射器会 `@ResquestMapping` 标记的方法进行映射和寻找：
- `value`：设置1或N个方法路由，自动以类上的路由为前缀（若有）：
    - `?`：匹配一个字符，如 `/?/one`。
    - `*`：匹配任意字符，如 `/*/two`。
    - `**`：匹配多层路径，如 `/**/three`。
- `method`：限定1或N种请求方式，值为枚举类 `RequestMethod`：
    - `RequestMethod.GET`：仅接收GET请求，其余请求报错，其余同理。
    - 特殊请求限定方式参考 `z-res/特殊请求限定.md`。
- `params`：限定1或N种请求参数，不满足直接报错：
    - `age/!age`：必须有/没有 `name` 属性，值无所谓。
    - `age=18/age!=18`：必须有 `age=18` 键值对，若有 `age` 则值必须不能为 `18`。

**源码：** /springmvc4/
- src: `c.j.controller.RequestMappingController`
- psm: `/api/request-mapping/value-a`
- psm: `/api/request-mapping/value-b`
- psm: `/api/request-mapping/a/b/user-delete/1`
- psm: `/api/request-mapping/method`
- psm: `/api/request-mapping/params`

# 2. 接值

**概念：** 因默认值问题，不建议使用任何基本类型接值：
- Cookie参数：对方法参数使用 `@CookieValue` 可以获取Cookie中指定key值信息。
- 请求头参数：对方法参数使用 `@RequestHeader` 可以获取请求头指定key值信息。
- REST参数：对方法参数使用 `@PathVariable` 可以获取方法路由中的指定占位符对应的信息：
    - 路由中需使用 `{}` 标记占位符，对应请求URL的REST参数，与 `@PathVariable` 指定key值同名。
    - REST参数和请求后缀如 `.do` 写法不兼容。
- 键值对简单参数：对方法参数使用 `@RequestParam` 可以获取指定key的键值对请求参数：
    - 使用简单类型如 `Integer/Double/Boolean/String` 等接收请求参数在同名时可省略注解。
    - 使用布尔类型接收请求参数时可自动将 `1/0` 转型为 `true/false`。
    - 使用数组类型如 `Integer[]` 可批量接收同名请求参数。
    - 使用实体类接收请求参数时，要求实体类属性和请求参数同名。
    - 使用VO中实体类可接收格式为 `VO中实体类属性名.key` 的请求参数。
    - 使用VO中List可接收格式为 `VO中List属性[下标].key` 的请求参数，注意GET请求不识别 `[]`。
- POST请求中文乱码：在web.xml中配置编码过滤器 `o.s.w.f.CharacterEncodingFilter`：
    - 使用 `<init-param>` 注入 `encoding=utf-8`。
    
> 以上注解均可使用 `required` 和 `defaultValue` 设置必填和默认值。
    
**源码：** /springmvc4/
- src: `c.j.controller.ParamController`
- psm: `/api/param/cookie-value`
- psm: `/api/param/request-header`
- psm: `/api/param/path-variable`
- psm: `/api/param/request-param`

# 3. 存值

**概念：** 
- 请求域存值：动作方法形参中可直接使用 `ModelAndView/Model/ModelMap/Map` 实例：
    - `ModelAndView` 支持手动实例化，且可以获取 `Model/ModelMap` 实例。
    - `ModelAndView` 存值的生效前提是必须配合 `ModelAndView` 转页：
        - `mv.addObject(k, v)`：存值。
        - `mv.setViewName()`：设置逻辑视图名。
- 会话域存值：在类上使用 `@SessionAttributes` 可将请求域中的指定属性上升到会话域：
    - `value="name"`：将请求域中名为 `name` 的属性复制到会话域，支持数组。
    - `types=String.class`：将请求域中所有 `String` 类型的属性复制到会话域，支持数组。
- 前置方法：`@ModeAttribute` 标记的方法会在本类所有业务方法前执行：
    - 前置方法可直接获取请求参数，返回值为void。
    - 前置方法和业务方法处于同次请求中，且和所有业务方法共享请求域。

**源码：** /springmvc4/
- src: `c.j.controller.ScopeController`
- psm: `/api/scope/request-scope`
- psm: `/api/scope/session-scope`
- psm: `/api/scope/model-attribute`
- web: `view/success.jsp`

# 4. 转页

返回值为void
**概念：** 如果你的动作类方法的返回值设计为 `void`，则建议使用原生Servlet对象 `HttpServletRequest` 和 `HttpServletResponse` 这两个对象进行页面跳转或者JSON回写。

**源码：** ForwordController.java
```java
/**
 * @author JoeZhou
 */
@Controller
@RequestMapping("forward")
public class ForwardController {

    @RequestMapping("byServlet01.action")
    public void byServlet01(HttpServletRequest req, HttpServletResponse resp)
            throws ServletException, IOException {

        // 原生servlet请求转发
        req.getRequestDispatcher("/view/success.html").forward(req, resp);
    }

    @RequestMapping("byServlet02.action")
    public void byServlet02(HttpServletRequest req, HttpServletResponse resp)
            throws IOException {

        // 原生servlet重定向
        resp.sendRedirect(req.getContextPath() + "/forward/byServlet01.action");
    }

    @RequestMapping("byServlet03.action")
    public void byServlet03(HttpServletResponse response)
            throws IOException {

        // 原生servlet响应json数据
        response.getWriter().print("{\"age\":18}");
    }
}
```

> 测试接口：forward/byServlet01.action

> 测试接口：forward/byServlet02.action

> 测试接口：forward/byServlet03.action

# 2. 返回值为ModelAndView

**概念：** ModelAndView对象来是向request域中添加模型数据的，并且可以使用它进行页面跳转。
- ModelAndView支持直接在构造器中添加视图名。
- ModelAndView支持请求转发，此时会使用到视图解析器中的前后缀。
- ModelAndView支持重定向，重定向的时候是不支持前后缀的。

**源码：** ForwordController.java 中添加
```java
@RequestMapping("byModelAndView01.action")
public ModelAndView byModelAndView01() {
    return new ModelAndView("success");
}

@RequestMapping("byModelAndView02.action")
public ModelAndView byModelAndView02(ModelAndView mv) {
    mv.setViewName("redirect:/view/success.html");
    return mv;
}
```

> 测试接口：forward/byModelAndView01.action

> 测试接口：forward/byModelAndView02.action

# 3. 返回值为String

**概念：** String代表逻辑视图名，动作类方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址。
- 请求转发：
    - `return "success";`：转发到页面，使用前后缀。
    - `return "forward:/view/success.jsp?a=1";`：转发到页面，无法使用前后缀，允许使用查询串。
    - `return "forward:xxx.action";`：转发到另一个controller。
- 重定向：
    - `return "redirect:/view/success.jsp";`：重定向到页面，无法使用前后缀，无法使用查询串。
    - `return "redirect:xxx.action";`：重定向到另一个controller。


**源码：** ForwordController.java 中添加
```java
@RequestMapping("byString01.action")
public String byString01() {
    System.out.println("byString01...");
    return "success";
}

@RequestMapping("byString02.action")
public String byString02() {
    System.out.println("byString02...");
    return "forward:/view/success.html?a=1";
}

@RequestMapping("byString03.action")
public String byString03() {
    System.out.println("byString03...");
    return "forward:byString01.action";
}

@RequestMapping("byString04.action")
public String byString04() {
    System.out.println("byString04...");
    return "redirect:/view/success.html";
}

@RequestMapping("byString05.action")
public String byString05() {
    System.out.println("byString05...");
    return "redirect:byString02.action";
}
```

> 测试接口：forward/byString01.action

> 测试接口：forward/byString02.action

> 测试接口：forward/byString03.action

> 测试接口：forward/byString04.action

> 测试接口：forward/byString05.action

# 1. JSON常用框架

**概念：** 
- JSON常用框架有阿里fastjson，谷歌gson等等，它们主要的功能就是将一个JavaBean序列化为Json对象。
- 从性能上讲 Jackson > FastJson > Gson ，但它们各有自己的专长。

# 2. 检查注解驱动

**概念：** 确认springMVC的核心配置文件中配置了注解协调。

**配置：** springmvc.xml
```xml
<mvc:annotation-driven/>
```

# 3. 添加依赖

**配置：** pom.xml
```xml
<!--jackson-core-->
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-core</artifactId>
    <version>2.9.7</version>
</dependency>

<!--jackson-annotations-->
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-annotations</artifactId>
    <version>2.9.7</version>
</dependency>

<!--jackson-databind-->
<dependency>
    <groupId>com.fasterxml.jackson.core</groupId>
    <artifactId>jackson-databind</artifactId>
    <version>2.9.7</version>
</dependency>
```

# 4. 动作类

**概念：** 在方法上添加 `@ResponseBody`，告诉SpringMVC，此时返回的不是一个结果视图，而是一个AJAX调用，是一个JSON数据。

**源码：** JsonController.java
```java
/**
 * @author JoeZhou
 */
@RequestMapping("json")
@Controller
public class JsonController {

    @ResponseBody
    @RequestMapping("jsonMap.action")
    public List<Map<String, Object>> jsonMap() {
        List<Map<String, Object>> users = new ArrayList<>();
        Map<String, Object> map1 = new HashMap<>(10);
        map1.put("name", "赵四");
        map1.put("age", 58);
        Map<String, Object> map2 = new HashMap<>(10);
        map2.put("name", "刘能");
        map2.put("age", 68);
        users.add(map1);
        users.add(map2);
        return users;
    }

    @ResponseBody
    @RequestMapping("jsonPojo.action")
    public List<User> jsonPojo() {
        List<User> users = new ArrayList<>();
        User user1 = new User();
        user1.setName("赵四");
        user1.setAge(58);
        User user2 = new User();
        user2.setName("刘能");
        user2.setAge(68);
        users.add(user1);
        users.add(user2);
        return users;
    }
}
```

> 接口测试：json/jsonMap.action

> 接口测试：json/jsonPojo.action

# 5. @ResponseBody中文响应编码

**概念：** `@ResponseBody` 如果直接返回中文的话，会使用 `ISO-8859-1` 的编码展示，改变方案有两种：
- **局部设置：** 在 `@RequestMapping` 中添加 `produces` 属性，如下：
    - `@RequestMapping(value="/login.action", produces="text/html;charset=UTF-8")`
- **全局设置：** 在SpringMVC核心配置中进行全局修改，如下：

**配置：** springmvc.xml 的 `<mvc:annotation-driven>` 标签内部添加：
```xml
<mvc:message-converters>
    <bean class="org.springframework.http.converter.StringHttpMessageConverter">
        <property name="supportedMediaTypes">
            <list>
                <value>text/html;charset=UTF-8</value>
            </list>
        </property>
    </bean>
</mvc:message-converters>
```

**源码：** JsonController.java 中添加
```java
@ResponseBody
@RequestMapping(value = "responseString.action", produces = "text/html;charset=UTF-8")
public String responseString() {
    return "中文测试";
}
```

> 接口测试：json/responseString.action

# 6. Jackson的常用处理注解

**概念：**
- 指定字段忽略：`@JsonIgnore`
- 指定日期格式：`@JsonFormat(pattern="yyyy-MM-dd hh:mm:ss", locale="zh", timezone="GMT+8")`
- 空字段不返回：`@JsonInclude(Include.NON_NUll)`
- 指定别名：`@JsonProperty`，不对外暴露数据库名或字段名。

**源码：** Student.java
```java
/**
 * @author JoeZhou
 */
@Data
public class Student implements Serializable {
    @JsonIgnore
    private Integer id;

    @JsonInclude(JsonInclude.Include.NON_NULL)
    private String name;

    @JsonFormat(pattern="yyyy-MM-dd hh:mm:ss", locale="zh", timezone="GMT+8")
    private Date birthday;
}
```

**源码：** StudentController.java
```java
/**
 * @author JoeZhou
 */
@Controller
@RequestMapping("/student")
public class StudentController {

    @ResponseBody
    @RequestMapping("retrieve.action")
    public List<Student> retrieve() {

        List<Student> students = new ArrayList<>();

        Student student01 = new Student();
        student01.setId(1);
        student01.setName("赵桑");
        student01.setBirthday(new Date());
        Student student02 = new Student();
        student02.setId(2);
        student02.setBirthday(new Date());

        students.add(student01);
        students.add(student02);
        return students;
    }
}
```


