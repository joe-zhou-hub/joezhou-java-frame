# 1. 概念入门

**概念：** springmvc是spring框架的控制层技术，核心是前端控制器 `DispatcherServlet`，负责管理和调用其它组件以处理用户的http请求，降低组件间的耦合度：
- 当浏览器请求符合前端控制器规则时，WEB服务器会将其转交给前端控制器。
- 前端控制器调用处理器映射器 `HandlerMapping`：
    - 根据请求URL找到某自定义Handler，将其和拦截器（若有）封装成执行链并返回。
- 前端控制器调用处理器适配器 `HandlerAdapter`：
    - 执行执行链中拦截器和Handler并返回一个ModelAndView对象。
- 前端控制器调用视图解析器 `ViewResolver`：
    - 将ModelAndView中的逻辑视图名拼接前后缀后解析为物理视图名，并返回View对象。 
- 前端控制器根据View组装HTML页面响应给浏览器，浏览器渲染页面:
    - 渲染：浏览器解析HTML，构建DOM树，整合CSS和JS，布局，绘制等过程。

> z-image/一个核心三个组件.png

# 2. 基础配通

**流程：**
- 添加依赖：spring-webmvc
- 在web.xml中配置前端控制器类 `o.s.w.s.DispatcherServlet`：
    - 使用 `<init-param>` 注入 `contextConfigLocation=springmvc主配文件`：
        - 默认加载 `/WEB-INF/配对名-servlet.xml`。
    - 使用 `<url-pattern>` 设置前端控制器拦截规则，可设置多个：
        - `*.do/.action`：仅拦截以.do或.action结尾的请求。
        - `/`：拦截除JSP外的一切请求，此时静态资源请求需要在web.xml中手动放行。
        - `/*`：拦截包括JSP的一切请求，不建议。
- 开发springmvc主配文件：
    - 使用 `<mvc:annotation-driven />` 驱动管理处理器映射器类和处理器适配器类。
    - 使用 `<context:component-scan>` 包扫描 `@Component`。
    - 管理视图解析器类：`o.s.w.s.v.InternalResourceViewResolver`：
        - 注入 `prifix` 以配置响应路径前缀，可选。
        - 注入 `suffix` 以配置响应路径后缀，可选。
- 开发动作类：添加 `@Controller`。
- 开发动作方法：添加 `@RequestMapping` 设置方法路由，可省略两端 `/` 和 `.do` 后缀：
    - 修饰符必须 `public`，方法名随意。
    - 若返回字符串，会自动拼接视图解析器前后缀并执行请求转发。
- 测试：请求URL中不可省略 `.do` 后缀（若有）。

**源码：** /springmvc4/
- res: `pom.xml`
- res: `WEB-INF/web.xml`
- res: `classpath:spring/springmvc.xml`
- src: `c.j.start.StartController`
- psm: `{{tomcat}}/springmvc3/api/start/start`

# 3. @RequestMapping

**概念：** 注解式处理器映射器会 `@ResquestMapping` 标记的方法进行映射和寻找：
- `value` 用于为方法设置一个或多个路由，自动以类上的路由为前缀（若有）：
    - `?` 用于匹配单层路径中的一个字符，如 `/?/one`。
    - `*` 用于匹配单层路径中的任意字符，如 `/*/two`。
    - `**` 用于匹配多层路径，如 `/**/three`。
- `method` 用于限定一个或多个请求方式，值为 `RequestMethod` 枚举类：
    - `RequestMethod.GET` 表示只接收GET请求，其余请求报错。
    - `RequestMethod.POST` 表示只接收POST请求，其余请求报错。
- POST乱码在：web.xml中配置编码过滤器 `o.s.w.f.CharacterEncodingFilter`：
    - 使用 `<init-param>` 注入 `encoding=utf-8`。

> z-res/特殊请求限定.md

**源码：** /springmvc4/
- src: `c.j.start.RequestMappingController`
- psm: `{{tomcat}}/springmvc4/api/request-mapping/test-a`
- psm: `{{tomcat}}/springmvc4/api/request-mapping/test-b`
- psm: `{{tomcat}}/springmvc4/api/request-mapping/test-c`
- psm: `{{tomcat}}/springmvc4/api/request-mapping/a/one`
- psm: `{{tomcat}}/springmvc4/api/request-mapping/abc/two`
- psm: `{{tomcat}}/springmvc4/api/request-mapping/a/b/c/three`

**源码：**
```java
@RequestMapping(value = "/test04.action", method = RequestMethod.GET)
public String test04() {
    System.out.println("test04!!!");
    return "success";
}
```

## 3.2 POST乱码问题

**配置：** web.xml 中添加
```xml
<filter>
    <filter-name>characterEncodingFilter</filter-name>
    <filter-class>org.springframework.web.filter.CharacterEncodingFilter</filter-class>
    <init-param>
        <param-name>encoding</param-name>
        <param-value>UTF-8</param-value>
    </init-param>
</filter>
<filter-mapping>
    <filter-name>characterEncodingFilter</filter-name>
    <url-pattern>/*</url-pattern>
</filter-mapping>
```



# 4. 参数限定

**概念：** `@RequestMapping` 中可以利用 `params` 属性来限定请求进来的参数。
- `params="name"`：必须传给我 `name`，`name` 里是什么值无所谓，否则会报错。
- `params="name=zhaosi"`：必须传给我 `name` 且值必须为 `zhaosi`，否则会报错。
- `params={"name=zhaosi", "age!=18"}`：必须传给我 `name` 且值为 `zhaosi`，如果传给我 `age` 则不能是 `18`，如果不传就算了，否则会报错。
- `params="!name"`：不能传给我 `name`，否则会报错。
**源码：**
```java
@RequestMapping(value = "/test05.action", params = "username")
public String test05(String username, String password) {
    System.out.println(username);
    System.out.println(password);
    return "success";
}
```

# 1. servlet原生对象支持

**概念：** springmvc默认支持的参数类型的 `HttpServletRequest`、`HttpServletResponse` 和 `HttpSession`。

# 2. 依赖

**配置：** pom.xml
```xml
<!--javax.servlet-api-->
<dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>javax.servlet-api</artifactId>
    <version>3.1.0</version>
    <scope>provided</scope>
</dependency>
```

# 3. 动作类

**源码：** ServletController.java
```java
/**
 * @author JoeZhou
 */
@Controller
@RequestMapping("/servlet")
public class ServletController {

    @RequestMapping("/request.action")
    public String request(HttpServletRequest request) {
        System.out.println(request);
        return "success";
    }

    @RequestMapping("/response.action")
    public String response(HttpServletResponse response) {
        System.out.println(response);
        return "success";
    }

    @RequestMapping("/session.action")
    public String session(HttpSession session) {
        System.out.println(session);
        return "success";
    }

    @RequestMapping("/application.action")
    public String application(HttpServletRequest request, HttpSession session) {
        ServletContext application01 = request.getServletContext();
        ServletContext application02 = session.getServletContext();
        System.out.println(application01);
        System.out.println(application02);
        return "success";
    }
}
```
