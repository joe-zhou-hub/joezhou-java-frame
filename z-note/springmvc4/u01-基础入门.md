# 1. 概念入门

**概念：** springmvc是spring框架的控制层技术，核心是前端控制器 `DispatcherServlet`，负责管理和调用其它组件以处理用户的http请求，降低组件间的耦合度：
- 当浏览器请求符合前端控制器规则时，WEB服务器会将其转交给前端控制器。
- 前端控制器调用处理器映射器 `HandlerMapping`：
    - 根据请求URL找到某自定义Handler，将其和拦截器（若有）封装成执行链并返回。
- 前端控制器调用处理器适配器 `HandlerAdapter`：
    - 执行执行链中拦截器和Handler并返回一个ModelAndView对象。
- 前端控制器调用视图解析器 `ViewResolver`：
    - 将ModelAndView中的逻辑视图名拼接前后缀后解析为物理视图名，并返回View对象。 
- 前端控制器根据View组装HTML页面响应给浏览器，浏览器渲染页面:
    - 渲染：浏览器解析HTML，构建DOM树，整合CSS和JS，布局，绘制等过程。

> z-image/一个核心三个组件.png

## 1.1 配通

**流程：** 添加 `spring-webmvc` 依赖：
- 在web.xml中配置前端控制器类 `o.s.w.s.DispatcherServlet`：
    - 使用 `<init-param>` 注入 `contextConfigLocation=springmvc主配文件`：
        - 默认加载 `/WEB-INF/配对名-servlet.xml`。
    - 使用 `<url-pattern>` 设置前端控制器拦截规则，可设置多个：
        - `*.do/.action`：仅拦截以.do或.action结尾的请求。
        - `/`：拦截除JSP外的一切请求，静态资源请求需在web.xml中手动放行。
        - `/*`：拦截包括JSP的一切请求，静态资源请求需在web.xml中手动放行，不建议。
- 开发springmvc主配文件：
    - 使用 `<mvc:annotation-driven />` 驱动管理处理器映射器类和处理器适配器类。
    - 使用 `<context:component-scan />` 包扫描 `@Component`。
    - 管理视图解析器类：`o.s.w.s.v.InternalResourceViewResolver`：
        - 注入 `prifix` 以配置响应路径前缀，可选。
        - 注入 `suffix` 以配置响应路径后缀，可选。
- 开发动作类：添加 `@Controller`。
- 开发动作方法：添加 `@RequestMapping` 设置方法路由，可省略两端 `/` 和 `.do` 后缀：
    - 修饰符必须 `public`，方法名随意。
    - 若返回字符串，会自动拼接视图解析器前后缀并执行请求转发。
- 测试：请求URL中不可省略 `.do` 后缀（若有）。

**源码：** /springmvc4/
- res: `pom.xml`
- res: `WEB-INF/web.xml`
- res: `classpath:spring/springmvc.xml`
- src: `c.j.controller.StartController`
- psm: `{{tomcat}}/springmvc4/api/start`

## 1.2 @RequestMapping

**概念：** 注解式处理器映射器会 `@ResquestMapping` 标记的方法进行映射和寻找：
- `value`：设置1或N个方法路由，自动以类上的路由为前缀（若有）：
    - `?`：匹配一个字符，如 `/?/one`。
    - `*`：匹配任意字符，如 `/*/two`。
    - `**`：匹配多层路径，如 `/**/three`。
- `method`：限定1或N种请求方式，值为枚举类 `RequestMethod`：
    - `RequestMethod.GET`：仅接收GET请求，其余请求报错，其余同理。
    - 特殊请求限定方式参考 `z-res/特殊请求限定.md`。
- `params`：限定1或N种请求参数，不满足直接报错：
    - `age/!age`：必须有/没有 `name` 属性，值无所谓。
    - `age=18/age!=18`：必须有 `age=18` 键值对，若有 `age` 则值必须不能为 `18`。

**源码：** /springmvc4/
- src: `c.j.controller.RequestMappingController`
- psm: `{{tomcat}}/springmvc4/api/request-mapping/value-a`
- psm: `{{tomcat}}/springmvc4/api/request-mapping/value-b`
- psm: `{{tomcat}}/springmvc4/api/request-mapping/a/b/user-delete/1`
- psm: `{{tomcat}}/springmvc4/api/request-mapping/method`
- psm: `{{tomcat}}/springmvc4/api/request-mapping/params`

# 2. 接值

**概念：** 因默认值问题，不建议使用任何基本类型接值：
- Cookie参数：对方法参数使用 `@CookieValue` 可以获取Cookie中指定key值信息。
- 请求头参数：对方法参数使用 `@RequestHeader` 可以获取请求头指定key值信息。
- REST参数：对方法参数使用 `@PathVariable` 可以获取方法路由中的指定占位符对应的信息：
    - 路由中需使用 `{}` 标记占位符，对应请求URL的REST参数，与 `@PathVariable` 指定key值同名。
    - REST参数和请求后缀如 `.do` 写法不兼容。
- 键值对简单参数：对方法参数使用 `@RequestParam` 可以获取指定key的键值对请求参数：
    - 使用简单类型如 `Integer/Double/Boolean/String` 等接收请求参数在同名时可省略注解。
    - 使用布尔类型接收请求参数时可自动将 `1/0` 转型为 `true/false`。
    - 使用数组类型如 `Integer[]` 可批量接收同名请求参数。
    - 使用实体类接收请求参数时，要求实体类属性和请求参数同名。
    - 使用VO中实体类可接收格式为 `VO中实体类属性名.key` 的请求参数。
    - 使用VO中List可接收格式为 `VO中List属性[下标].key` 的请求参数，注意GET请求不识别 `[]`。
- POST中文乱码问题：在web.xml中配置编码过滤器 `o.s.w.f.CharacterEncodingFilter`：
    - 使用 `<init-param>` 注入 `encoding=utf-8`。
    
> 以上注解均可使用 `required` 和 `defaultValue` 设置必填和默认值。
    
**源码：** /springmvc4/
- src: `c.j.controller.ParamController`
- psm: `{{tomcat}}/springmvc4/api/param/cookie-value`
- psm: `{{tomcat}}/springmvc4/api/param/request-header`
- psm: `{{tomcat}}/springmvc4/api/param/path-variable`
- psm: `{{tomcat}}/springmvc4/api/param/request-param`

# 3. 存值

请求域存值
**概念：** 
- SpingMVC支持五种请求域存值方法：
    - 使用原生Servlet对象 `HttpRequest` 进行存值。
    - 使用 `ModelAndView` 进行存值。
    - 使用 `Model` 进行存值。
    - 使用 `ModelMap` 进行存值。
    - 使用 `Map` 进行存值。
- 请求域存值有效期为一次请求，跳页时如果使用重定向则页面端取不到值。
- EL取值需要使用jsp文件，需要视图解析器中将 `.html` 后缀改为 `.jsp` 后缀，如果idea中不支持EL表达式，页面需要在第一行添加：
    - `<%@ page isELIgnored="false" %>`

## 2. ModelAndView

**概念：**
- **获取方法：** 在方法形参中注入，也可以自己new。
- **存值：** `addObject(K, V)` 
- **EL取值：** `${requestScope["K"]}`
- **备注：** 使用 `ModelAndView` 存值，就必须使用 `ModelAndView` 转页。

**源码：** ValueController.java
```java
/**
 * @author JoeZhou
 */
@RequestMapping("value")
@Controller
public class ValueController {

    @RequestMapping("modelAndView.action")
    public ModelAndView modelAndView(ModelAndView mv) {
        
        // 设置存值的KV内容
        mv.addObject("modelAndView-name", "取值成功！");
        
        // 设置转页路径
        mv.setViewName("value");
        return mv;
    }
}
```

**布局** value.jsp
```html
<p>modelAndView-name：${requestScope["modelAndView-name"]}</p>
```

> 测试接口：value/modelAndView.action

## 3. Model

**概念：**
- **获取方法：** 在方法形参中注入，也可以通过 `ModelAndView` 实例获取。
- **存值：** `addAttribute(K, V)` 
- **EL取值：** `${requestScope["K"]}`
- **备注：** `Model` 是一个接口。

**源码：** ValueController.java 中添加
```java
@RequestMapping("model.action")
public String model(Model model) {
    model.addAttribute("model-name", "取值成功！");
    return "value";
}
```

**布局** value.jsp
```html
<p>model-name：${requestScope["model-name"]}</p>
```

> 测试接口：value/model.action

## 4. ModelMap

**概念：**
- **获取方法：** 在方法形参中注入，也可以通过 `ModelAndView` 实例获取。
- **存值：** `addAttribute(K, V)` 或者 `put(K, V)`
- **EL取值：** `${requestScope["K"]}`
- **备注：** `ModelMap` 是 `Map` 接口的一个实现类。

**源码：** ValueController.java 中添加
```java
@RequestMapping("modelMap.action")
public String model(ModelMap modelMap) {
    modelMap.addAttribute("modelMap-name1", "取值成功！");
    modelMap.put("modelMap-name2", "取值成功！");
    return "value";
}
```

**布局** value.jsp
```html
<p>modelMap-name1：${requestScope["modelMap-name1"]}</p>
<p>modelMap-name2：${requestScope["modelMap-name2"]}</p>
```

> 测试接口：value/modelMap.action

## 5. Map

**概念：**
- **获取方法：** 在方法形参中注入，也可以通过 `ModelAndView` 实例获取。
- **存值：** `put(K, V)`
- **EL取值：** `${requestScope["K"]}`

**源码：** ValueController.java 中添加
```java
@RequestMapping("map.action")
public String map(Map<String, Object> map) {
    map.put("map-name", "取值成功！");
    return "value";
}
```

**布局** value.jsp
```html
<p>map-name：${requestScope["map-name"]}</p>
```

> 测试接口：value/map.action

## 6. @SessionAttributes

**概念：** SpingMVC支持两种会话域存值方法：
- 使用原生Servlet对象 `HttpSession` 进行存值。
- 如果在一个类上加 `@SessionAttributes("abc")`，则可以将 `abc` 的值复制一份到session域中，但前提是，`abc` 已存在于request域中，这个过程简称作用域上升。

### 2. 按照key值上升

**概念：** 按照key值，将requst域中的指定值复制到session域：
- `@SessionAttributes("username")`：将request域中 `username` 对应的值上升到session域中。
- `@SessionAttributes({"username", "password"})`：将request域中 `username` 和 `password` 对应的值上升到session域中。

**源码：** SessionController.java
```java
/**
 * @author JoeZhou
 */
@SessionAttributes("session-key")
@RequestMapping("session")
@Controller
public class SessionController {
    
    @RequestMapping("sessionByKeyCopy.action")
    public String session(Map<String, Object> map) {
        map.put("session-key", "session-value");
        return "sessionValue";
    }
}
```

**布局** sessionValue.jsp
```html
<p>从request域中取值：${requestScope["session-key"]}</p>
<p>从session域中取值：${sessionScope["session-key"]}</p>
```

> 测试接口：session/sessionByKeyCopy.action

### 2. 按照类型上升

**概念：** 将requst域中的所有指定类型的值复制到session域：
- `@SessionAttributes(types = String.class)`：将request域中所有String类型的值上升到session域中。
- `@SessionAttributes(types = {String.class, Integer.class})`：将request域中所有String类型和Integer类型的值上升到session域中，即使存放的是int类型，也需要使用 `Integer` 来指定。

**源码：** SessionController.java 中修改
```java
/**
 * @author JoeZhou
 */
@SessionAttributes(types = String.class)
@RequestMapping("session")
@Controller
public class SessionController {
    @RequestMapping("sessionByTypeCopy.action")
    public String session(Map<String, Object> map) {
        map.put("session-String", "session-value");
        map.put("session-int", 15);
        return "sessionValue";
    }
}
```

**布局** sessionValue.jsp
```html
<p>从session域中取出String类型的值：${sessionScope["session-String"]}</p>
<p>从session域中取出Integer类型的值：${sessionScope["session-int"]}</p>
```

> 测试接口：session/sessionByKeyCopy.action

## 7. @ModeAttribute

**概念：** 
- 在方法上添加 `@ModeAttribute`，会让这个方法成为本类中所有其他方法的前置方法，即本类中所有方法在执行之前，都会先执行该方法。
- `@ModeAttribute` 的设计思想是，尽量一个控制器类只做一件事情。
- `@ModeAttribute` 修饰的前置方法和业务方法属于在同一次请求中，所以请求域中存放的值对于这两个方法来说是共享的。

### 2. 使用@ModeAttribute进行修改

**需求：** 将id为1的数据的姓名改为 `liuneng`，但需要保证 `性别` 和 `年龄` 维持原值。

#### 2.1 实体类

**源码：** User.java
```java
@Data
public class User implements Serializable {
    private Integer id;
    private String name;
    private String gender;
    private Integer age;
}
```

#### 2.2 动作类

**源码：** ModelAttributeController.java
```java
/**
 * @author JoeZhou
 */
@RequestMapping("modelAttribute")
@Controller
public class ModelAttributeController {

    /**
     * 前置方法：模拟通过id将User查询出来了
     */
    @ModelAttribute
    public void retrieveById(User user, Map<String, Object> map) {
        System.out.println("前置方法：取得客户端参数: " + user);
        // 模拟通过ID查询User
        User userFromDataBase = new User();
        userFromDataBase.setId(user.getId());
        userFromDataBase.setName("赵四");
        userFromDataBase.setGender("男");
        userFromDataBase.setAge(58);
        System.out.println("前置方法：通过ID获取到对应user的原内容：" + userFromDataBase);
        // 将userFromDataBase存起来
        map.put("userFromDataBase", userFromDataBase);
    }

    /**
     * 业务方法：修改用户信息
     */
    @RequestMapping("update.action")
    public String updateById(User user, Map<String, Object> map) {
        System.out.println("业务方法：取得客户端参数：" + user);
        User userFromDataBase = (User) map.get("userFromDataBase");
        System.out.println("业务方法：取得前置方法中存储的值：" + userFromDataBase);
        userFromDataBase.setName(user.getName());
        System.out.println("修改用户信息完毕！");
        map.put("user", userFromDataBase);
        return "user";
    }
}
```

#### 2.3 页面取值

**布局：** user.jsp
```html
<p>${requestScope["user"]}</p>
```

> 测试接口：modelAttribute/update.action?id=1&name=刘能
