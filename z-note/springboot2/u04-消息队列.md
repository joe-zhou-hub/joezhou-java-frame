# 1. ActiveMQ

**流程：** 安装MQ

- **链接：** [activemq官网](http://activemq.apache.org/)
- **链接：** [apache-activemq-5.15.13-bin.zip](http://note.youdao.com/noteshare?id=eb86d2ac764cf926e00f415f40f7af42&sub=0CE5C8B4C02A4E79AF07BA3135588CC2)

**安装流程：**
1. 启动 `%HOME%\bin\win64\activemq.bat`
2. 访问 `http://127.0.0.1:8161`
3. 账号密码都是 `admin`
4. 点击 `Manage ActiveMQ broker` 启动控制台，管理activemq代理，其中：
    - `queues`：操作队列：输入队列名，建议命名规则为：`队列名.queue`，然后点击 `create` 可以创建一个队列。
        - `Name`：队列名称
        - `Number Of Pending Messages`：等待消费的消息数。
        - `Number Of Consumers`：消费者数。
        - `Messages Enqueued`：队列中的总消息数，包括待消费和已消费的，只增不减。
        - `Messages Dequeued`：已消费的消息数。
    - `Topics`：发布中心详情。
    - `Subscribers`：订阅者详情。
    - `Connections`：连接详情。
    - `Network`：IP网络详情。
    - `Scheduler`：定时器详情。
    - `send` 向队列发送消息：在 `destination` 一栏输入队列名，然后在最下面的 `message body` 中输入消息，点击 `send` 即可。

# 2. springboot整合MQ准备

**概念：** springboot整合MQ需要三步准备：
1. 添加activemq的相关依赖。
2. 在配置文件中开启对activemq的相关支持。
3. 在启动类上添加 `@EnableJms` 支持JMS。

**配置：** pom.xml
```xml
<!--spring-boot-starter-activemq-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-activemq</artifactId>
</dependency>

<!--pooled-jms-->
<dependency>
    <groupId>org.messaginghub</groupId>
    <artifactId>pooled-jms</artifactId>
    <version>1.0.4</version>
</dependency>
```

**配置：** application.yml
```txt
spring:
  activemq:
    # 集群broker-url=failover:(tcp://localhost:61616,tcp://localhost:61617)
    broker-url: tcp://127.0.0.1:61616
    user: admin
    password: admin
    pool:
      enabled: true
      max-connections: 50
```

> 如果你的activemq安装到别的机器，记得防火墙要关闭。

# 3. 点对点模型整合

## 3.1 消息生产类

**概念：** `JmsMessagingTemplate` 中的 `convertAndSend()` 可以将消息发送到broker。

**源码：** MyProducer.java
```java
/**
 * @author JoeZhou
 */
@Component
public class MyProducer {
    private JmsMessagingTemplate jmsMessagingTemplate;

    @Autowired
    public MyProducer(JmsMessagingTemplate jmsMessagingTemplate) {
        this.jmsMessagingTemplate = jmsMessagingTemplate;
    }

    public void sendMsgToBrokerQueue(Destination destination, final Object message) {
        jmsMessagingTemplate.convertAndSend(destination, message);
    }
}
```

> import javax.jms.Destination;

## 3.2 动作类

**源码：** MyProducerController.java
```java
/**
 * @author JoeZhou
 */
@RestController
@RequestMapping("api/p2p")
public class MyProducerController {

    private MyProducer myMessageProducer;

    @Autowired
    public MyProducerController(MyProducer myMessageProducer) {
        this.myMessageProducer = myMessageProducer;
    }

    @RequestMapping("send-msg-to-broker-queue")
    public Object sendMsgToBrokerQueue(String msg) {
        Destination destination = new ActiveMQQueue("start.queue");
        myMessageProducer.sendMsgToBrokerQueue(destination, msg);
        return "success";
    }
}
```

> 测试接口：localhost:8080/api/p2p/send-msg-to-broker-queue.action

## 3.3 消息消费者类

**概念：** 在消费者中我们使用某个类来监听broker中的某个队列，一旦某个队列更新了消息，它都会进行实施操作。
- `@JmsListener` 让方法具有监听行为。
- `destination` 属性指定了具体监听的队列。
- 方法中使用 `ActiveMQTextMessage` 参数类型进行接收，其中的 `text` 就是字符串类型的消息内容。

**源码：** MyConsumer.java
```java
/**
 * @author JoeZhou
 */
@Component
public class MyConsumer {
    @JmsListener(destination = "start.queue")
    public void receiveMsgFromBrokerQueue(ActiveMQTextMessage activeMQTextMessage) {
        try {
            System.out.println("consumer接受到消息：" + activeMQTextMessage.getText());
        } catch (JMSException e) {
            e.printStackTrace();
        }
    }
}
```

# 4. 发布订阅模型整合

**概念：** activemq默认支持点对点模型，如果想使用发布订阅模型需要添加额外配置：`spring.jms.pub-sub-domain=true`。

## 4.1 消息发布类

**概念：** `JmsMessagingTemplate` 中的 `convertAndSend()` 可以将消息发布到broker。

**源码：** MyPublish.java
```java
/**
 * @author JoeZhou
 */
@Component
public class MyPublish {
    private JmsMessagingTemplate jmsMessagingTemplate;

    @Autowired
    public MyPublish(JmsMessagingTemplate jmsMessagingTemplate) {
        this.jmsMessagingTemplate = jmsMessagingTemplate;
    }

    public void publish(Destination destination, final Object message) {
        jmsMessagingTemplate.convertAndSend(destination, message);
    }
}
```

## 4.2 动作类

**源码：** MyPublishController.java
```java
/**
 * @author JoeZhou
 */
@RestController
@RequestMapping("api/pub-sub")
public class MyPublishController {

    private MyPublish myPublish;

    @Autowired
    public MyPublishController(MyPublish myPublish) {
        this.myPublish = myPublish;
    }

    @RequestMapping("publish-msg-to-broker-topic.action")
    public Object publishMsgToBrokerTopic(String msg) {
        Destination destination = new ActiveMQTopic("start.topic");
        myPublish.publishMsgToBrokerTopic(destination, msg);
        return "success";
    }
}
```

> 测试接口：localhost:8080/api/pub-sub/public-msg-to-broker-topic.action

## 4.3 订阅者类

**概念：** 使用方法和消费者类相似，这里使用两个方法来模拟多个订阅用户。

**源码：** MySubscriber.java
```java
/**
 * @author JoeZhou
 */
@Component
public class MySubscriber {

    @JmsListener(destination = "start.topic")
    public void receiveMsgFromBrokerTopic01(ActiveMQTextMessage activeMQTextMessage) {
        try {
            System.out.println("subscriber02接受到消息：" + activeMQTextMessage.getText());
        } catch (JMSException e) {
            e.printStackTrace();
        }
    }

    @JmsListener(destination = "start.topic")
    public void receiveMsgFromBrokerTopic02(ActiveMQTextMessage activeMQTextMessage) {
        try {
            System.out.println("subscriber02接受到消息：" + activeMQTextMessage.getText());
        } catch (JMSException e) {
            e.printStackTrace();
        }
    }
}
```

# 5. 同时支持点对点和发布订阅

**概念：** activemq的点对点模型和发布订阅模型默认不能共存。

1. 注释掉 `spring.jms.pub-sub-domain=true` 配置。
2. 在订阅者类的每个监听方法注解 `@JmsListener` 中添加 `containerFactory = "jmsListenerContainerTopic"` 属性。
3. 在启动类重写Jms监听工厂，如下：

**源码：** 启动类中添加
```java
@Bean
public JmsListenerContainerFactory<?> jmsListenerContainerTopic(ConnectionFactory activeMQConnectionFactory) {
    DefaultJmsListenerContainerFactory bean = new DefaultJmsListenerContainerFactory();
    bean.setPubSubDomain(true);
    bean.setConnectionFactory(activeMQConnectionFactory);
    return bean;
}
```

