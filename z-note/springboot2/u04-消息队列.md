# 1. 概念入门

**概念：** 消息队列 `Message Queue` 简称MQ，即存放消息的FIFO队列，主要用于对进程或线程间通信进行解耦，对高并发任务进行削峰，提高程序性能：
- 消息队列使用原则：尽可能提高消息入队速度，灵活调整消息出队速度。
- 消息队列技术特点：
    - 消息不丢失：MQ采取put-get-delete模式，仅在消息被完整处理后才会将其删除。
    - 进程无关联：MQ下游进程崩溃，上游进程仍可继续put，等待下游恢复。
    - 处理不重复：MQ中的一个消息仅被处理一次，被某个下游进程获取时会锁定。
    - 处理可延时：MQ中的消息可以被延时处理，更加灵活。

# 2. ActiveMQ

**流程：** [activemq官网](http://activemq.apache.org/) 是apache公司的一个消息队列产品：
- 启动 `%ACTIVEMQ_HOME%\bin\win64\activemq.bat`
- 访问 `127.0.0.1:8161` 进入AMQ管理界面，账密都是 `admin`。
- 点击 `Manage ActiveMQ broker` 管理AMQ的经纪人（管控台）。
- 创建队列：点击 `queues` 选项卡，输入以 `queue` 后缀的队列名，点击 `create`：
    - `Name`：队列名称
    - `Number Of Pending Messages`：待消费消息数。
    - `Number Of Consumers`：消费者数。
    - `Messages Enqueued`：总消息数，包括待消费和已消费的，只增不减。
    - `Messages Dequeued`：已消费消息数。
- 向队列发送消息：点击 `send` 选项卡，输入目标队列名和消息内容，点击 `send`：
    - `destination`：目标队列名。
    - `message body`：消息内容。

## 2.1 springboot整合

**流程：** 新建springboot-jar项目 `springboot2-activemq`
- 配置pom依赖：`spring-boot-starter-activemq/pooled-jms`
- 主配开启AMQ：均以 `spring.activemq` 前缀：
    - `broker-url=tcp://localhost:61616`：连接AMQ经纪人，默认端口61616。
    - `broker-url=failover:(tcp://localhost:61616,tcp://localhost:61617)`：连接AMQ经纪人集群。
    - `user=admin`：TCP账号为admin。
    - `password=admin`：TCP连接密码为admin。
    - `pool.enabled=true`：开启AMQ池。
    - `pool.max-connections=50`：AMQ池最大容量为50个连接。
- 启动类上添加 `@EnableJms` 支持JMS。

## 2.2 生产消费模型

**流程：** 生产者生产消息，所有消费者轮流消费该消息：
- 开发生产者类 `c.j.s.producer.ProducerA`：注入 `o.s.j.c.JmsMessagingTemplate` 类：
    - `new ActiveMQQueue(queueName)`：根据队列名创建 `Destination` 对象，名不存在自动创建。
    - `jmsMessagingTemplate.convertAndSend(destination, msg)`：向目标队列发送消息。
- 开发动作类 `c.j.s.controller.ProducerController`：注入生产者类并调用其发送消息方法。
- 开发消费者类 `c.j.s.consumer.ConsumerA/ConsumerB`：
    - 消费方法标记 `@JmsListener`：当 `destination` 指定的队列有新消息时执行。
    - 消费方法对形参 `ActiveMQTextMessage` 调用 `getText()` 可接收字符串消息。
- psm测试：`producer/send-to-queue`

## 2.3 发布订阅模型

**流程：** 发布者发布消息，所有订阅者同时消费该消息：
- 开发监听配置类 `c.j.s.config.JmsListenerConfig` 并IOC `o.s.j.c.JmsListenerContainerFactory`：
    - `<bean>` 的id固定为 `jmsListenerContainerTopic`。
    - `<bean>` 的class建议使用 `o.s.j.c.DefaultJmsListenerContainerFactory` 类。
    - `bean.setConnectionFactory(connectionFactory)`：设置用于获取JMS的工厂，传入方法入参即可。
    - `bean.setPubSubDomain(true)`：设置支持发布订阅模型。
- 开发发布者类 `c.j.s.publish.PublishA`：注入 `o.s.j.c.JmsMessagingTemplate` 类：
    - `new ActiveMQTopic(topicName)`：根据主题名创建 `Destination` 对象，名不存在自动创建。
    - `jmsMessagingTemplate.convertAndSend(destination, msg)`：向目标主题发送消息。
- 开发动作类 `c.j.s.controller.PublishController`：注入发布者类并调用其发送消息方法。
- 开发订阅者类 `c.j.s.subscriber.SubscriberA/SubscriberB`：
    - 消费方法标记 `@JmsListener`：当 `destination` 指定的队列有新消息时执行。
    - `@JmsListener` 添加 `containerFactory="jmsListenerContainerTopic"` 以支持发布订阅模型。
    - 消费方法对形参 `ActiveMQTextMessage` 调用 `getText()` 可接收字符串消息。
- psm测试：`publish/send-to-topic`

# 3. RocketMQ

**概念：** [rocketmq官网](http://rocketmq.apache.org/) 阿里巴巴开源的一款高性能，高吞吐量的分布式MQ，源于jms规范但不遵守jms规范。对于分布式只一点，如果你了用过其他mq并且了解过rocketmq，就知道rocketmq天生就是分布式的，可以说是broker、provider、consumer等各种分布式。
- RMQ特点：
    - 在高压下1毫秒内响应延迟超过99.6％。
    - 适合金融类业务，高可用性跟踪和审计功能。
    - 支持发布订阅模型，和点对点
    - 支持拉pull和推push两种消息模
    - 单一队列百万消息
	- 支持单master节点，多master节点，多master多slave节点		
- RMQ环境变量：
    - `ROCKETMQ_HOME` = `"D:\rocketmq"`
    - `NAMESRV_ADDR` = `"localhost:9876"`
    - `path` = `%ROCKETMQ_HOME%\bin`
- cmd: `mqnamesrv.cmd -n localhost:9876` 启动RMQ服务。
- cmd: `mqbroker.cmd -n localhost:9876 autoCreateTopicEnable=true` 启动broker且自动创建topic。
- RMQ可视化界面：自行下载安装 `rocketmq-externals`： 
    - 打开 `%HOME%\rocketmq-console\src\main\resources\application.properties` 文件。
    - 修改配置 `server.port=12581`：默认8080，和tomcat冲突。
    - 修改配置 `rocketmq.config.namesrvAddr=localhost:9876`：配置RMQ服务端地址，默认 `*`。
    - 进入 `%HOME%\rocketmq-console` 目录。
    - cmd: `mvn clean package -Dmaven.test.skip=true` 打jar包。
    - 找到 `%HOME%\rocketmq-console\target\rocketmq-console-ng-1.0.1.jar` 文件。
    - cmd: `java -jar rocketmq-console-ng-1.0.1.jar` 运行jar包
    - cli: `http://localhost:12581` 进入RMQ管理界面。

## 3.1 springboot整合MQ准备

**概念：** springboot整合MQ需要两步准备：
1. 添加rocketmq的相关依赖。
2. 在配置文件中开启对rocketmq的相关配置。

**配置：** pom.xml
```xml
<!--rocketmq-client-->
<dependency>
    <groupId>org.apache.rocketmq</groupId>
    <artifactId>rocketmq-client</artifactId>
    <version>4.7.1</version>
</dependency>

<!--rocketmq-common-->
<dependency>
    <groupId>org.apache.rocketmq</groupId>
    <artifactId>rocketmq-common</artifactId>
    <version>4.7.1</version>
</dependency>
```

> 依赖的版本号要和你部署在机器上的MQ服务一致。

**配置：** application.yml
```txt
# rocketmq相关配置
# 这里的配置是自定义的，代码会高亮不识别
# producer-group-name 表示生产者组名，自定义
# consumer-group-name 表示消费者组名，自定义
# name-srv-addr 表示MQ服务地址
joe:
  rocketmq:
    producer-group-name: my-producer
    consumer-group-name: my-consumer
    name-srv-addr: 127.0.0.1:9876
```

> 如果你的rocketmq安装到别的机器，记得防火墙要关闭。

## 3.2 生产者类

**概念：** 
- `@PropertySource：` 用于读取属性文件，默认会去加载classpath下的所有文件，可省略，建议指定。
- `@Value：` 读取属性文件中的值：需要读取生产者组名和MQ服务地址。
- `@PostConstruct：` 相当于servlet的init功能，在对象的构造器执行完了，就会立马调用该方法，且只执行一次，内容为：
    - 创建一个生产者对象：同时将其放在指定的生产者组中，若没有这个生产者组会自动创建。
    - 指定NameServer地址：集群以分号分隔，如：`"192.168.1.1:9876;192.168.1.2:9876;"`;
    - 关闭vip通道：rocketmq默认开启了端口为10909的VIP通道，若rocketmq服务未启动端口10909，则会报 `connect to <> failed` 错误。
    - 初始化生产者对象：在使用生产者对象前必须要调用 `start()` 进行初始化，且只能调用一次。
    - 对外提供一个方法，能够将生产者对象返回。

**源码：** MyProducer.java
```java
/**
 * @author JoeZhou
 */
@PropertySource("classpath:application.yml")
@Component
public class MyProducer {

    @Value("${joe.rocketmq.producer-group-name}")
    private String producerGroupName;

    @Value("${joe.rocketmq.name-srv-addr}")
    private String nameSrvAddr;

    private DefaultMQProducer producer;

    @PostConstruct
    public void init() {
        producer = new DefaultMQProducer(producerGroupName);
        producer.setNamesrvAddr(nameSrvAddr);
        producer.setVipChannelEnabled(false);
        try {
            producer.start();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public DefaultMQProducer getMyProducer() {
        return producer;
    }
}
```

## 3.3 消费者类

**概念：** 
- `@PropertySource：` 用于读取属性文件，默认会去加载classpath下的所有文件，可省略，建议指定。
- `@Value：` 读取属性文件中的值：需要读取消费者组名和MQ服务地址。
- `@PostConstruct：` 相当于servlet的init功能，在对象的构造器执行完了，就会立马调用该方法，且只执行一次，内容为：
    - 创建一个消费者对象：同时将其放在指定的消费者组中，若没有这个消费者组会自动创建。
    - 指定NameServer地址：集群以分号分隔，如：`"192.168.1.1:9876;192.168.1.2:9876;"`;
    - 订阅一个话题：利用 `subscribe()` 指定订阅哪些消息，不满足条件的会被过滤掉：
        - p1：指定 `topic` 名，只能指定一个，不是这个 `topic` 名的消息会被过滤掉。
        - p2：指定 `tag` 名，可以使用 `|` 同时指定多个，如果是 `null` 或者 `*` 表示订阅所有标签。
        - 若 `topic` 或 `tag` 不能存在会自动创建，如果启动MQ服务时没有添加 `autoCreateTopicEnable=true` 参数，则这个 `topic` 需要手动创建。
    - 为话题挂载监听：这里使用Lambda表达式：
        - `messageExt.getBody()`：获取消息体。
        - `ConsumeConcurrentlyStatus.RECONSUME_LATER` 表示稍后再试。
        - `ConsumeConcurrentlyStatus.CONSUME_SUCCESS` 表示消费成功。
    - 初始化消费者对象：在使用消费者对象前必须要调用 `start()` 进行初始化，且只能调用一次。

**源码：** MyConsumer.java
```java
/**
 * @author JoeZhou
 */
@PropertySource("classpath:application.yml")
@Component
public class MyConsumer {

    @Value("${joe.rocketmq.consumer-group-name}")
    private String consumerGroupName;

    @Value("${joe.rocketmq.name-srv-addr}")
    private String nameSrvAddr;

    @PostConstruct
    public void init() {
        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(consumerGroupName);
        consumer.setNamesrvAddr(nameSrvAddr);
        try {
            consumer.subscribe("my-topic", "my-tag");
            consumer.registerMessageListener((MessageListenerConcurrently) (list, context) -> {
                try {
                    for (MessageExt messageExt : list) {
                        System.err.println("消费消息: " + new String(messageExt.getBody()));
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                    return ConsumeConcurrentlyStatus.RECONSUME_LATER;
                }
                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
            });
            consumer.start();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

## 3.4 动作类

**概念：** 
- `@PropertySource：` 
- 注入生产者类 `MyProducer` 备用。
- 在动作类中接受 `tag` 内容和 `msg` 具体消息，`topic` 写死，和 `MyConsumer` 中监听的 `topic` 名保持一致。
- 构建 `Message` 对象：全名 `org.apache.rocketmq.common.message.Message`，构造器参数为：
    - p1：`topic` 名。
    - p2：`tag` 名。
    - p3：`msg` 具体消息的UTF-8编码字节数组形式，编码推荐使用远程助手设置 `RemotingHelper.DEFAULT_CHARSET`。
- 获取生产者对象，通过生产者生产消息，并调用 `send()` 将其发送到broker。
- `send()` 返回值是一个 `SendResult` 对象：
    - `getMsgId()`：可以获得的消息ID。
    - `getSendStatus()`：可以获得发送状态。

**源码：** MyRocketMqController.java
```java
/**
 * @author JoeZhou
 */
@RestController
@RequestMapping("api/rocketmq")
public class MyRocketMqController {

    private MyProducer myProducer;

    @Autowired
    public UserController(MyProducer myProducer) {
        this.myProducer = myProducer;
    }

    @RequestMapping("send.action")
    public void send(String tag, String msg)
            throws UnsupportedEncodingException, InterruptedException,
            RemotingException, MQClientException, MQBrokerException {
        String topic = "my-topic";
        Message message = new Message(topic, tag, msg.getBytes(RemotingHelper.DEFAULT_CHARSET));
        SendResult result = myProducer.getMyProducer().send(message);
        System.out.println("<< msg-id: " + result.getMsgId());
        System.out.println("<< status: " + result.getSendStatus());
    }
}
```

> 测试接口：http://localhost:8080/api/rocketmq/send.action?tag=my-tag&msg=helloworld

> 在IDEA控制台查看监听信息，在MQ控制台页面点击message，选择 `my-topic` 然后点击 `search` 查看，点击 `message detail` 可以查看更详细的信息。