# 1. 概念入门

**概念：** 消息队列 `Message Queue` 简称MQ，即存放消息的队列，主要用于不同进程或线程间通信。
- 不同进程（process）之间传递消息时，两个进程之间耦合程度过高，改动一个进程，引发必须修改另一个进程，为了隔离这两个进程，在两进程间抽离出一层（一个模块），所有两进程之间传递的消息，都必须通过消息队列来传递，单独修改某一个进程，不会影响另一个；
- 不同进程（process）之间传递消息时，为了实现标准化，将消息的格式规范化了，并且，某一个进程接受的消息太多，一下子无法处理完，并且也有先后顺序，必须对收到的消息进行排队，因此诞生了事实上的消息队列；
 
 
 
 
 
        　　不管到底是什么原因催生了消息队列，总之，上面两个猜测是其实际应用的典型场景。
        　　为什么要用
           通过消息队列，将短时间高并发产生的事务消息存储在消息队列中，从而削平高峰期的并发事务，改善网站系统的性能。在京东之类的电子商务网站促销活动中，合理地使用消息    队列，可以有效地抵御促销活动刚开始就开始大量涌入的订单对系统造成的冲击。
        　　切合前一部分猜测的消息队列产生背景，其主要解决两个问题：
        系统解耦：项目开始时，无法确定最终需求，不同进程间，添加一层，实现解耦，方便今后的扩展。
        消息缓存：系统中，不同进程处理消息速度不同，MQ，可以实现不同Process之间的缓冲，即，写入MQ的速度可以尽可能地快，而处理消息的速度可以适当调整（或快、或慢）。
             
        
        　　下面针对系统解耦、消息缓存两点，来分析实际应用消息队列过程中，可能遇到的问题。虚拟场景：Process_A通过消息队列MQ_1向Process_B传递消息，几个问题：
        针对MQ_1中一条消息message_1，如何确保Process_B从MQ_1中只取一次message_1，不会重复多次取出message_1？
        如果MQ_1中message_1已经被Process_B取出，正在处理的关键时刻，Process_B崩溃了，哭啊，我的问题是，如果重启Process_B，是否会丢失message_1？
        　　不要着急，阅读了下面的简要介绍后，水到渠成，上面几个问题就可以解决了。 消息队列有如下几个好处，这大都是由其系统解耦和消息缓存两点扩展而来的：
        提升系统可靠性：
        冗余：Process_B崩溃之后，数据并不会丢失，因为MQ多采用put-get-delete模式，即，仅当确认message被完成处理之后，才从MQ中移除message；
        可恢复：MQ实现解耦，部分进程崩溃，不会拖累整个系统瘫痪，例，Process_B崩溃之后，Process_A仍可向MQ中添加message，并等待Process_B恢复；
        可伸缩：有较强的峰值处理能力，通常应用会有突发的访问流量上升情况，使用足够的硬件资源时刻待命，空闲时刻较长，资源浪费，而消息队列却能够平滑峰值流量，缓解系统组件的峰值压力；
        提升系统可扩展性：
        调整模块：由于实现解耦，可以很容易调整，消息入队速率、消息处理速率、增加新的Process；
        其他：
        单次送达：保证MQ中一个message被处理一次，并且只被处理一次。本质：get获取一个message后，这一message即被预定，同一进程不会再次获取这一message；当且仅当进程处理完这一message后，MQ中会delete这个message。否则，过一段时间后，这一message自动解除被预订状态，进程能够重新预定这个message；
        排序保证：即，满足队列的FIFO，先入先出策略；
        异步通信：很多场景下，不会立即处理消息，这是，可以在MQ中存储message，并在某一时刻再进行处理；
        数据流的阶段性能定位：获取用户某一操作的各个阶段（通过message来标识），捕获不同阶段的耗时，可用于定位系统瓶颈。

# 2. ActiveMQ

**流程：** [activemq官网](http://activemq.apache.org/) 是apache公司的一个消息队列产品：
- 启动 `%ACTIVEMQ_HOME%\bin\win64\activemq.bat`
- 访问 `127.0.0.1:8161` 进入AMQ管理界面，账密都是 `admin`。
- 点击 `Manage ActiveMQ broker` 管理AMQ的经纪人（管控台）。
- 创建队列：点击 `queues` 选项卡，输入以 `queue` 后缀的队列名，点击 `create`：
    - `Name`：队列名称
    - `Number Of Pending Messages`：待消费消息数。
    - `Number Of Consumers`：消费者数。
    - `Messages Enqueued`：总消息数，包括待消费和已消费的，只增不减。
    - `Messages Dequeued`：已消费消息数。
- 向队列发送消息：点击 `send` 选项卡，输入目标队列名和消息内容，点击 `send`：
    - `destination`：目标队列名。
    - `message body`：消息内容。

## 1.1 springboot整合

**流程：** 新建springboot-jar项目 `springboot2-activemq`
- 配置pom依赖：`spring-boot-starter-activemq/pooled-jms`
- 主配开启AMQ：均以 `spring.activemq` 前缀：
    - `broker-url=tcp://localhost:61616`：连接AMQ经纪人，默认端口61616。
    - `broker-url=failover:(tcp://localhost:61616,tcp://localhost:61617)`：连接AMQ经纪人集群。
    - `user=admin`：TCP账号为admin。
    - `password=admin`：TCP连接密码为admin。
    - `pool.enabled=true`：开启AMQ池。
    - `pool.max-connections=50`：AMQ池最大容量为50个连接。
- 启动类上添加 `@EnableJms` 支持JMS。

**流程：** 生产消费模型：生产者生产消息，所有消费者轮流消费该消息：
- 开发生产者类 `c.j.s.producer.ProducerA`：注入 `o.s.j.c.JmsMessagingTemplate` 类：
    - `new ActiveMQQueue(queueName)`：根据队列名创建 `Destination` 对象，名不存在自动创建。
    - `jmsMessagingTemplate.convertAndSend(destination, msg)`：向目标队列发送消息。
- 开发动作类 `c.j.s.controller.ProducerController`：注入生产者类并调用其发送消息方法。
- 开发消费者类 `c.j.s.consumer.ConsumerA/ConsumerB`：
    - 消费方法标记 `@JmsListener`：当 `destination` 指定的队列有新消息时执行。
    - 消费方法对形参 `ActiveMQTextMessage` 调用 `getText()` 可接收字符串消息。
- psm测试：`producer/send-to-queue`，多次发送，控制台查看消费情况。

**流程：** 发布订阅模型：发布者发布消息，所有订阅者同时消费该消息：
- 主配添加 `spring.jms.pub-sub-domain=true` 以支持发布订阅模型，此时生产消费模型失效。
- 开发发布者类 `c.j.s.publish.PublishA`：注入 `o.s.j.c.JmsMessagingTemplate` 类：
    - `new ActiveMQTopic(topicName)`：根据主题名创建 `Destination` 对象，名不存在自动创建。
    - `jmsMessagingTemplate.convertAndSend(destination, msg)`：向目标主题发送消息。
- 开发动作类 `c.j.s.controller.PublishController`：注入发布者类并调用其发送消息方法。
- 开发订阅者类 `c.j.s.subscriber.SubscriberA/SubscriberB`：
    - 消费方法标记 `@JmsListener`：当 `destination` 指定的队列有新消息时执行。
    - 消费方法对形参 `ActiveMQTextMessage` 调用 `getText()` 可接收字符串消息。
- psm测试：`publish/send-to-topic`，多次发送，控制台查看消费情况。

**流程：** 同时支持两种模型：
- 删除主配中的 `spring.jms.pub-sub-domain=true` 配置项目。
- 仅对所有订阅者 `@JmsListener` 添加 `containerFactory="jmsListenerContainerTopic"` 属性。
- 开发jsm监听工厂配置类 `c.j.s.config.JmsListenerConfig`

