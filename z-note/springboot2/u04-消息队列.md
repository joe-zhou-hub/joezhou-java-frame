# 1. 概念入门

**概念：** 消息队列 `Message Queue` 简称MQ，即存放消息的FIFO队列，主要用于对进程或线程间通信进行解耦，对高并发任务进行削峰，提高程序性能：
- 消息队列使用原则：尽可能提高消息入队速度，灵活调整消息出队速度。
- 消息队列技术特点：
    - 消息不丢失：MQ采取put-get-delete模式，仅在消息被完整处理后才会将其删除。
    - 进程无关联：MQ下游进程崩溃，上游进程仍可继续put，等待下游恢复。
    - 处理不重复：MQ中的一个消息仅被处理一次，被某个下游进程获取时会锁定。
    - 处理可延时：MQ中的消息可以被延时处理，更加灵活。

# 2. ActiveMQ

**流程：** [activemq官网](http://activemq.apache.org/) 是apache公司的一个消息队列产品：
- 启动 `%ACTIVEMQ_HOME%\bin\win64\activemq.bat`
- 访问 `127.0.0.1:8161` 进入AMQ管理界面，账密都是 `admin`。
- 点击 `Manage ActiveMQ broker` 管理AMQ的经纪人（管控台）。
- 创建队列：点击 `queues` 选项卡，输入以 `queue` 后缀的队列名，点击 `create`：
    - `Name`：队列名称
    - `Number Of Pending Messages`：待消费消息数。
    - `Number Of Consumers`：消费者数。
    - `Messages Enqueued`：总消息数，包括待消费和已消费的，只增不减。
    - `Messages Dequeued`：已消费消息数。
- 向队列发送消息：点击 `send` 选项卡，输入目标队列名和消息内容，点击 `send`：
    - `destination`：目标队列名。
    - `message body`：消息内容。

## 2.1 springboot整合

**流程：** 新建springboot-jar项目 `springboot2-activemq`
- 配置pom依赖：`spring-boot-starter-activemq/pooled-jms`
- 主配开启AMQ：均以 `spring.activemq` 前缀：
    - `broker-url=tcp://localhost:61616`：连接AMQ经纪人，默认端口61616。
    - `broker-url=failover:(tcp://localhost:61616,tcp://localhost:61617)`：连接AMQ经纪人集群。
    - `user=admin`：TCP账号为admin。
    - `password=admin`：TCP连接密码为admin。
    - `pool.enabled=true`：开启AMQ池。
    - `pool.max-connections=50`：AMQ池最大容量为50个连接。
- 启动类上添加 `@EnableJms` 支持JMS。

## 2.2 生产消费模型

**流程：** 生产者生产消息，所有消费者轮流消费该消息：
- 开发生产者类 `c.j.s.producer.ProducerA`：注入 `o.s.j.c.JmsMessagingTemplate` 类：
    - `new ActiveMQQueue(queueName)`：根据队列名创建 `Destination` 对象，名不存在自动创建。
    - `jmsMessagingTemplate.convertAndSend(destination, msg)`：向目标队列发送消息。
- 开发动作类 `c.j.s.controller.ProducerController`：注入生产者类并调用其发送消息方法。
- 开发消费者类 `c.j.s.consumer.ConsumerA/ConsumerB`：
    - 消费方法标记 `@JmsListener`：当 `destination` 指定的队列有新消息时执行。
    - 消费方法对形参 `ActiveMQTextMessage` 调用 `getText()` 可接收字符串消息。
- psm测试：`producer/send-to-queue`

## 2.3 发布订阅模型

**流程：** 发布者发布消息，所有订阅者同时消费该消息：
- 开发监听配置类 `c.j.s.config.JmsListenerConfig` 并IOC `o.s.j.c.JmsListenerContainerFactory`：
    - `<bean>` 的id固定为 `jmsListenerContainerTopic`。
    - `<bean>` 的class建议使用 `o.s.j.c.DefaultJmsListenerContainerFactory` 类。
    - `bean.setConnectionFactory(connectionFactory)`：设置用于获取JMS的工厂，传入方法入参即可。
    - `bean.setPubSubDomain(true)`：设置支持发布订阅模型。
- 开发发布者类 `c.j.s.publish.PublishA`：注入 `o.s.j.c.JmsMessagingTemplate` 类：
    - `new ActiveMQTopic(topicName)`：根据主题名创建 `Destination` 对象，名不存在自动创建。
    - `jmsMessagingTemplate.convertAndSend(destination, msg)`：向目标主题发送消息。
- 开发动作类 `c.j.s.controller.PublishController`：注入发布者类并调用其发送消息方法。
- 开发订阅者类 `c.j.s.subscriber.SubscriberA/SubscriberB`：
    - 消费方法标记 `@JmsListener`：当 `destination` 指定的队列有新消息时执行。
    - `@JmsListener` 添加 `containerFactory="jmsListenerContainerTopic"` 以支持发布订阅模型。
    - 消费方法对形参 `ActiveMQTextMessage` 调用 `getText()` 可接收字符串消息。
- psm测试：`publish/send-to-topic`

# 3. RocketMQ

**概念：** [rocketmq官网](http://rocketmq.apache.org/) 阿里巴巴开源的一款高性能，高吞吐量的分布式MQ，源于jms规范但不遵守jms规范。对于分布式只一点，如果你了用过其他mq并且了解过rocketmq，就知道rocketmq天生就是分布式的，可以说是broker、provider、consumer等各种分布式。
- rocketmq特点：
    - 在高压下1毫秒内响应延迟超过99.6％。
    - 适合金融类业务，高可用性跟踪和审计功能。
    - 支持发布订阅模型，和点对点
    - 支持拉pull和推push两种消息模
    - 单一队列百万消息
	- 支持单master节点，多master节点，多master多slave节点		

## 3.1 rocket-mq本地快速部署

**概念：** 
1. 官方建议安装在 `64bit OS, Linux/Unix/Mac` 下，如果安装在Windows，需要最低版本10。
2. 安装RocketMQ4前提是安装了 `64bit JDK 1.8+`;
3. 下载binary release安装包：
    - [下载地址](https://www.apache.org/dyn/closer.cgi?path=rocketmq/4.7.1/rocketmq-all-4.7.1-bin-release.zip)，选择 `https://mirror.bit.edu.cn/apache/rocketmq/4.7.1/rocketmq-all-4.7.1-bin-release.zip`。
    - [rocketmq-all-4.7.1-bin-release.zip](http://note.youdao.com/noteshare?id=d6153df819d36b31bbf622228057f0b3&sub=450044517B92454BB56A49B6D5BF7E0A)
4. 将压缩包解压缩成文件夹。
5. 配置环境变量：
    - `ROCKETMQ_HOME` = `"D:\rocketmq"`
    - `NAMESRV_ADDR` = `"localhost:9876"`
    - `path` = `%ROCKETMQ_HOME%\bin`  
6. CMD启动mq服务：`mqnamesrv.cmd -n localhost:9876`
7. CMD启动borer服务：`mqbroker.cmd -n localhost:9876 autoCreateTopicEnable=true`
    - `autoCreateTopicEnable=true`：允许自动创建Topic，否则需要手动创建，很麻烦。
8. 这两个窗口不要关闭，关闭则表示关闭了对应服务。

## 3. RocketMQ4可视化控制台

**概念：** 和ActiveMQ自带控制台界面不同，RocketMQ的控制台界面需要自行拓展安装。
1. `rocketmq-externals` 中提供了很多RocketMQ的拓展件，每个拓展件都是一个springboot项目。
    - [github地址](https://github.com/apache/rocketmq-externals)
    - [rocketmq-externals-master.zip](http://note.youdao.com/noteshare?id=17dcf5e21f2e7b616578640da09d38bf&sub=40595C0FA4B24A2F8310C82925F864D5)
2. 打开 `%ROCKETMQ_HOME%\rocketmq-console\src\main\resources\application.properties` 修改配置：
    - `server.port=12581`：控制台默认端口是8080，和tomcat冲突。
    - `rocketmq.config.namesrvAddr=localhost:9876`：连接到我们的RocketMQ服务，默认是 `*`。
3. CMD进入到 `%ROCKETMQ_HOME%\rocketmq-console` 目录下。
4. 打包命令：`mvn clean package -Dmaven.test.skip=true`。
5. 打包后看到 `%ROCKETMQ_HOME%\rocketmq-console\target` 下出现 `rocketmq-console-ng-1.0.1.jar`。
6. 运行springboot项目：`java -jar rocketmq-console-ng-1.0.1.jar`。
7. 运行浏览器，访问：`http://localhost:12581/`，界面参见ActiveMQ。

## 4. springboot整合MQ准备

**概念：** springboot整合MQ需要两步准备：
1. 添加rocketmq的相关依赖。
2. 在配置文件中开启对rocketmq的相关配置。

**配置：** pom.xml
```xml
<!--rocketmq-client-->
<dependency>
    <groupId>org.apache.rocketmq</groupId>
    <artifactId>rocketmq-client</artifactId>
    <version>4.7.1</version>
</dependency>

<!--rocketmq-common-->
<dependency>
    <groupId>org.apache.rocketmq</groupId>
    <artifactId>rocketmq-common</artifactId>
    <version>4.7.1</version>
</dependency>
```

> 依赖的版本号要和你部署在机器上的MQ服务一致。

**配置：** application.yml
```txt
# rocketmq相关配置
# 这里的配置是自定义的，代码会高亮不识别
# producer-group-name 表示生产者组名，自定义
# consumer-group-name 表示消费者组名，自定义
# name-srv-addr 表示MQ服务地址
joe:
  rocketmq:
    producer-group-name: my-producer
    consumer-group-name: my-consumer
    name-srv-addr: 127.0.0.1:9876
```

> 如果你的rocketmq安装到别的机器，记得防火墙要关闭。

## 5. 生产者类

**概念：** 
- `@PropertySource：` 用于读取属性文件，默认会去加载classpath下的所有文件，可省略，建议指定。
- `@Value：` 读取属性文件中的值：需要读取生产者组名和MQ服务地址。
- `@PostConstruct：` 相当于servlet的init功能，在对象的构造器执行完了，就会立马调用该方法，且只执行一次，内容为：
    - 创建一个生产者对象：同时将其放在指定的生产者组中，若没有这个生产者组会自动创建。
    - 指定NameServer地址：集群以分号分隔，如：`"192.168.1.1:9876;192.168.1.2:9876;"`;
    - 关闭vip通道：rocketmq默认开启了端口为10909的VIP通道，若rocketmq服务未启动端口10909，则会报 `connect to <> failed` 错误。
    - 初始化生产者对象：在使用生产者对象前必须要调用 `start()` 进行初始化，且只能调用一次。
    - 对外提供一个方法，能够将生产者对象返回。

**源码：** MyProducer.java
```java
/**
 * @author JoeZhou
 */
@PropertySource("classpath:application.yml")
@Component
public class MyProducer {

    @Value("${joe.rocketmq.producer-group-name}")
    private String producerGroupName;

    @Value("${joe.rocketmq.name-srv-addr}")
    private String nameSrvAddr;

    private DefaultMQProducer producer;

    @PostConstruct
    public void init() {
        producer = new DefaultMQProducer(producerGroupName);
        producer.setNamesrvAddr(nameSrvAddr);
        producer.setVipChannelEnabled(false);
        try {
            producer.start();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    public DefaultMQProducer getMyProducer() {
        return producer;
    }
}
```

## 6. 消费者类

**概念：** 
- `@PropertySource：` 用于读取属性文件，默认会去加载classpath下的所有文件，可省略，建议指定。
- `@Value：` 读取属性文件中的值：需要读取消费者组名和MQ服务地址。
- `@PostConstruct：` 相当于servlet的init功能，在对象的构造器执行完了，就会立马调用该方法，且只执行一次，内容为：
    - 创建一个消费者对象：同时将其放在指定的消费者组中，若没有这个消费者组会自动创建。
    - 指定NameServer地址：集群以分号分隔，如：`"192.168.1.1:9876;192.168.1.2:9876;"`;
    - 订阅一个话题：利用 `subscribe()` 指定订阅哪些消息，不满足条件的会被过滤掉：
        - p1：指定 `topic` 名，只能指定一个，不是这个 `topic` 名的消息会被过滤掉。
        - p2：指定 `tag` 名，可以使用 `|` 同时指定多个，如果是 `null` 或者 `*` 表示订阅所有标签。
        - 若 `topic` 或 `tag` 不能存在会自动创建，如果启动MQ服务时没有添加 `autoCreateTopicEnable=true` 参数，则这个 `topic` 需要手动创建。
    - 为话题挂载监听：这里使用Lambda表达式：
        - `messageExt.getBody()`：获取消息体。
        - `ConsumeConcurrentlyStatus.RECONSUME_LATER` 表示稍后再试。
        - `ConsumeConcurrentlyStatus.CONSUME_SUCCESS` 表示消费成功。
    - 初始化消费者对象：在使用消费者对象前必须要调用 `start()` 进行初始化，且只能调用一次。

**源码：** MyConsumer.java
```java
/**
 * @author JoeZhou
 */
@PropertySource("classpath:application.yml")
@Component
public class MyConsumer {

    @Value("${joe.rocketmq.consumer-group-name}")
    private String consumerGroupName;

    @Value("${joe.rocketmq.name-srv-addr}")
    private String nameSrvAddr;

    @PostConstruct
    public void init() {
        DefaultMQPushConsumer consumer = new DefaultMQPushConsumer(consumerGroupName);
        consumer.setNamesrvAddr(nameSrvAddr);
        try {
            consumer.subscribe("my-topic", "my-tag");
            consumer.registerMessageListener((MessageListenerConcurrently) (list, context) -> {
                try {
                    for (MessageExt messageExt : list) {
                        System.err.println("消费消息: " + new String(messageExt.getBody()));
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                    return ConsumeConcurrentlyStatus.RECONSUME_LATER;
                }
                return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;
            });
            consumer.start();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

## 7. 动作类

**概念：** 
- `@PropertySource：` 
- 注入生产者类 `MyProducer` 备用。
- 在动作类中接受 `tag` 内容和 `msg` 具体消息，`topic` 写死，和 `MyConsumer` 中监听的 `topic` 名保持一致。
- 构建 `Message` 对象：全名 `org.apache.rocketmq.common.message.Message`，构造器参数为：
    - p1：`topic` 名。
    - p2：`tag` 名。
    - p3：`msg` 具体消息的UTF-8编码字节数组形式，编码推荐使用远程助手设置 `RemotingHelper.DEFAULT_CHARSET`。
- 获取生产者对象，通过生产者生产消息，并调用 `send()` 将其发送到broker。
- `send()` 返回值是一个 `SendResult` 对象：
    - `getMsgId()`：可以获得的消息ID。
    - `getSendStatus()`：可以获得发送状态。

**源码：** MyRocketMqController.java
```java
/**
 * @author JoeZhou
 */
@RestController
@RequestMapping("api/rocketmq")
public class MyRocketMqController {

    private MyProducer myProducer;

    @Autowired
    public UserController(MyProducer myProducer) {
        this.myProducer = myProducer;
    }

    @RequestMapping("send.action")
    public void send(String tag, String msg)
            throws UnsupportedEncodingException, InterruptedException,
            RemotingException, MQClientException, MQBrokerException {
        String topic = "my-topic";
        Message message = new Message(topic, tag, msg.getBytes(RemotingHelper.DEFAULT_CHARSET));
        SendResult result = myProducer.getMyProducer().send(message);
        System.out.println("<< msg-id: " + result.getMsgId());
        System.out.println("<< status: " + result.getSendStatus());
    }
}
```

> 测试接口：http://localhost:8080/api/rocketmq/send.action?tag=my-tag&msg=helloworld

> 在IDEA控制台查看监听信息，在MQ控制台页面点击message，选择 `my-topic` 然后点击 `search` 查看，点击 `message detail` 可以查看更详细的信息。