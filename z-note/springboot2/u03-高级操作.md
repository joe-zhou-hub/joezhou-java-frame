# 1. Servlet原生组件
     
**概念：** springboot支持原生的servlet组件，如servlet过滤器和servlet监听器等：
- 开发原生servlet类 `c.j.s.servlet.BeanServlet`，无需添加注解。
- 开发原生过滤器类 `c.j.s.servlet.filter.BeanFilter`，无需添加注解。
- 开发原生监听器类 `c.j.s.servlet.listener.BeanListener`，无需添加注解。
- 开发配置类 `c.j.s.servlet.BeanServletConfig`：
    - IOC `o.s.b.w.s.ServletRegistrationBean` 类，利用构造传入servlet实例和路由。
- 开发配置类 `c.j.s.servlet.filter.BeanFilterConfig`：
    - IOC `o.s.b.w.s.FilterRegistrationBean` 过滤器链类。
    - `filters.setFilter()`：在过滤器链中加入自定义过滤器。
    - `filters.addUrlPatterns()`：在过滤器链中加入自定义过滤器拦截规则。
- 开发配置类 `c.j.s.servlet.listener.BeanListenerConfig`：
    - IOC `o.s.b.w.s.ServletListenerRegistrationBean` 监听器类，利用构造传入监听器实例。
    - 每个监听对应一个 `@Bean`。
- psm测试：`/api/servlet/bean`。

## 1.1 注解配置方案

**流程：** 
- 开发原生servlet类 `c.j.s.servlet.ScanServlet`，标记 `@WebServlet`。
- 开发原生过滤器类 `c.j.s.servlet.filter.ScanFilter`，标记 `@WebFilter`。
- 开发原生监听器类 `c.j.s.servlet.listener.ScanListener`，标记 `@WebListener`。
- 在启动类中使用 `@ServletComponentScan` 扫描servlet类，过滤器类和监听器类所在包。
- psm测试：`/api/servlet/scan`。

## 1.2 同时配置方案

**流程：** 
- 开发原生servlet类 `c.j.s.servlet.ContextServlet`，无需添加注解。
- 开发原生过滤器类 `c.j.s.servlet.filter.ContextFilter`，无需添加注解。
- 开发原生监听器类 `c.j.s.servlet.listener.ContextListener`，无需添加注解。
- 让启动类实现 `ServletContextInitializer` 接口并重写 `onStartup()`：
    - `context.addServlet().addMapping()`：配置servlet类并设置路由。
    - `context.addFilter().addMappingForUrlPatterns()`：配置过滤器类并设置拦截规则。
    - `context.addListener()`：配置监听器类。
- psm测试：`/api/servlet/context`。

# 2. Spring拦截器

**流程：** 
- 配置pom依赖 `spring-boot-starter-aop`。
- 开发切面配置类 `c.j.s.aop.AopAspect`：标记 `@Aspect` 和 `@Configuration`。
    - 开发通知方法：如环绕通知 `@Around("execution()")`。
- 开发动作类 `c.j.s.aop.AopController`。
- psm测试：`/api/aop/execute`。

# 3. 全局异常

**概念：** 全局异常处理类的优先级低于异常通知，二者共存时，可以在异常通知处理中直接return错误信息，同样会返回给B端：
- 开发全局异常处理类 `c.j.s.exception.GlobalException`：标记 `@ControllerAdvice`：
    - 异常处理方法标记 `@ExceptionHandler` 以指定捕获哪些异常。
    - 异常处理方法标记 `@ResponseBody` 以返回异常信息内容。
- 开发动作类 `c.j.s.exception.ExceptionController`：开发一个会爆发异常的动作方法。
- psm测试：`/api/exception/execute`。

# 4. 定时任务

**概念：** springboot内置 `@EnableScheduling` 以替代 `java.util.Timer/TimerTask` 完成定时任务：
- 启动类标记 `@EnableScheduling` 以开启定时功能。
- 开发任务类 `c.j.s.schedule.ScheduleTask`：标记 `@Component` 以被spring管理。
- 开发任务方法并标记 `@Scheduled`：
    - `cron`：[CRON表达式](https://baike.baidu.com/item/cron)
    - `fixedDelay=1000`：立即执行任务，每次任务完成后计时，每隔1秒执行一次任务。
    - `fixedRate=1000`：立即执行任务，每次任务开始前计时，每隔1秒执行一次任务。
- 启动入口类，控制台观测任务执行情况。

# 5. 异步处理

**概念：** 异步执行方法不占用主线程资源，可以提高项目执行效率：
- 启动类上添加 `@EnableAsync` 开启异步功能。
- 开发任务类 `c.j.s.async.AsyncTask`：标记 `@Component` 被spring管理。
- 开发三个任务方法，分别模拟耗时1s/2s/3s：标记 `@Async` 以异步调用：
    - 若任务类中所有方法都是异步调用，则可将 `@Async` 标记在类上。
    - 方法返回值可封装在实现了 `Future` 接口的 `AsyncResult` 类中。
- 开发动作类 `c.j.s.async.AsyncController`：依次调用任务方法：
    - 对返回值调用 `isDone()` 可以判断任务是否已完成。
- psm：`api/async/execute`，观察到动作方法立刻返回结果，而三个方法在后台异步执行。
- psm：`api/async/executeWithReturn`，观察到。



 



