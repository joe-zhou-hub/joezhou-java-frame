# 1. Servlet原生组件
     
**概念：** springboot支持原生的servlet组件，如servlet过滤器和servlet监听器等：
- 开发原生servlet类 `c.j.s.servlet.BeanServlet`，无需添加注解。
- 开发原生过滤器类 `c.j.s.servlet.filter.BeanFilter`，无需添加注解。
- 开发原生监听器类 `c.j.s.servlet.listener.BeanListener`，无需添加注解。
- 开发配置类 `c.j.s.servlet.BeanServletConfig`：
    - IOC `o.s.b.w.s.ServletRegistrationBean` 类，利用构造传入servlet实例和路由。
- 开发配置类 `c.j.s.servlet.filter.BeanFilterConfig`：
    - IOC `o.s.b.w.s.FilterRegistrationBean` 过滤器链类。
    - `filters.setFilter()`：在过滤器链中加入自定义过滤器。
    - `filters.addUrlPatterns()`：在过滤器链中加入自定义过滤器拦截规则。
- 开发配置类 `c.j.s.servlet.listener.BeanListenerConfig`：
    - IOC `o.s.b.w.s.ServletListenerRegistrationBean` 监听器类，利用构造传入监听器实例。
    - 每个监听对应一个 `@Bean`。
- psm测试：`/api/servlet/bean`。

## 1.1 注解配置方案

**流程：** 
- 开发原生servlet类 `c.j.s.servlet.ScanServlet`，标记 `@WebServlet`。
- 开发原生过滤器类 `c.j.s.servlet.filter.ScanFilter`，标记 `@WebFilter`。
- 开发原生监听器类 `c.j.s.servlet.listener.ScanListener`，标记 `@WebListener`。
- 在启动类中使用 `@ServletComponentScan` 扫描servlet类，过滤器类和监听器类所在包。
- psm测试：`/api/servlet/scan`。

## 1.2 同时配置方案

**流程：** 
- 开发原生servlet类 `c.j.s.servlet.ContextServlet`，无需添加注解。
- 开发原生过滤器类 `c.j.s.servlet.filter.ContextFilter`，无需添加注解。
- 开发原生监听器类 `c.j.s.servlet.listener.ContextListener`，无需添加注解。
- 让启动类实现 `ServletContextInitializer` 接口并重写 `onStartup()`：
    - `context.addServlet().addMapping()`：配置servlet类并设置路由。
    - `context.addFilter().addMappingForUrlPatterns()`：配置过滤器类并设置拦截规则。
    - `context.addListener()`：配置监听器类。
- psm测试：`/api/servlet/context`。

# 2. Spring拦截器

**流程：** 
- 配置pom依赖 `spring-boot-starter-aop`。
- 开发切面配置类 `c.j.s.aop.AopAspect`：标记 `@Aspect` 和 `@Configuration`。
    - 开发通知方法：如环绕通知 `@Around("execution()")`。
- 开发动作类 `c.j.s.aop.AopController`。
- psm测试：`/api/aop/execute`。

# 3. 全局异常

**概念：** 全局异常处理类的优先级低于异常通知，二者共存时，可以在异常通知处理中直接return错误信息，同样会返回给B端：
- 开发全局异常处理类 `c.j.s.exception.GlobalException`：标记 `@ControllerAdvice`：
    - 异常处理方法标记 `@ExceptionHandler` 以指定捕获哪些异常。
    - 异常处理方法标记 `@ResponseBody` 以返回异常信息内容。
- 开发动作类 `c.j.s.exception.ExceptionController`：开发一个会爆发异常的动作方法。
- psm测试：`/api/exception/execute`。

# 4. 定时任务

**概念：** springboot内置 `@EnableScheduling` 以替代 `java.util.Timer/TimerTask` 完成定时任务：
- 启动类标记 `@EnableScheduling` 以开启定时功能。
- 开发任务类 `c.j.s.schedule.ScheduleTask`：标记 `@Component` 以被spring管理。
- 开发任务方法并标记 `@Scheduled`：
    - `cron`：[CRON表达式](https://baike.baidu.com/item/cron)
    - `fixedDelay=1000`：立即执行任务，每次任务完成后计时，每隔1秒执行一次任务。
    - `fixedRate=1000`：立即执行任务，每次任务开始前计时，每隔1秒执行一次任务。
- 启动入口类，控制台观测任务执行情况。

# 5. 异步处理

**概念：** 异步执行方法不占用主线程资源，可以提高项目执行效率：
- 启动类上添加 `@EnableAsync` 开启异步功能。
- 开发任务类 `c.j.s.async.AsyncTask`：标记 `@Component` 被spring管理。
- 开发三个任务方法，分别模拟耗时1s/2s/3s：标记 `@Async` 以异步调用：
    - 若任务类中所有方法都是异步调用，则可将 `@Async` 标记在类上。
    - 方法返回值可封装在实现了 `Future` 接口的 `AsyncResult` 类中。
- 开发动作类 `c.j.s.async.AsyncController`：依次调用任务方法：
    - 对返回值调用 `get()` 可以获取任务方法的返回值。
    - 对返回值调用 `isDone()` 可以判断任务是否已完成。
- psm：`api/async/execute`。

# 6. 响应式编程

**概念：** [webflux](https://docs.spring.io/spring-boot/docs/2.3.1.RELEASE/reference/html/spring-boot-features.html#boot-features-webflux) 是Spring5中的异步非阻塞响应式编程框架，不依赖servlet，不能部署为war包，不使用webapp目录，请求响应对象使用 `ServletRequest/ServletResponse`：
- 响应式编程：可利用较少的线程数或硬件资源来处理任务，提高系统的伸缩性，但不会让程序运行的更快：
    - `z-res/响应式编程举例.md`
- 创建springboot-jar项目 `springboot2-webflux`，选择 `Web/Spring Reactive Web` 依赖：
    - 手动配置需要添加pom依赖 `spring-boot-starter-webflux/reactor-test`。
    - `spring-boot-starter-webflux` 比 `spring-boot-starter-web` 优先级低，共存时失效。
- 启动入口类：启动方式由tomcat同步容器变为netty异步容器时表示成功引入webflux。
- 开发实体类 `c.j.s.pojo.User`。
- 开发业务接口 `c.j.s.service.UserService`：
    - 使用 `Mono<User>` 异步不阻塞返回单条User数据。
    - 使用 `Flux<User>` 异步不阻塞返回多条User数据。
- 开发业务类 `c.j.s.service.impl.UserServiceImpl`：
    - `Mono.just(user)`：返回 `Mono` 对象，参数为null或空时抛异常。
    - `Mono.justOrEmpty(user)`：返回 `Mono` 对象，参数为null或空时返回 `MonoEmpty` 对象。
    - `Flux.fromIterable(users)`：返回 `Flux` 集合对象。
    - `Flux.fromArray(users)`：返回 `Flux` 数组对象。
- 开发动作类 `c.j.s.controller.UserController`：动作方法可直接返回 `Mono/Flux` 对象。
    - `@RequestMaping` 配置 `produces="application/stream+json"` 可以开启流响应。
    - 对Flux数据调用 `delayElements(Duration.ofSeconds(2))` 可以设置响应流速为2秒一次。
- psm测试 `api/user/select-by-id`。
- cli测试 `api/user/select-all`，postman无法观察流响应效果。
- 开发WebClient类 `c.j.s.user.UserTest`：用于模拟发送webflux请求，必须先手动启动项目后测试：
    - `WebClient.create("uri").get()/post()`：创建并配置webflux的get/post请求。
    - `retrieve().bodyToMono/Flux(User.class)`：将User数据提取到Mono/Flux对象中。
    - `mono.block()`：立刻取出Mono中的数据。
    - `flux.collectList().block()`：将Flux中的数据收集到list中。

# 7. JWT校验

**概念：** [Json Web Token](https://jwt.io/) 是一种基于JSON的高效，简洁，安全的开放标准，使用一个 `header.payload.signature` 格式的token进行通信，常用于登录鉴权，单点登录等分布式场景：
- header：token头，描述使用哪种加密算法，如MD5/SHA/HAMC等：
    - MD5，message-digest algorithm 5，信息摘要算法，常用于校验文件，可生成唯一的MD5值。
    - SHA，Secure Hash Algorithm，安全散列算法，常用于密码学和数学应用项目中，安全性高于MD5。
    - HMAC，Hash Message Authentication Code，散列消息鉴别码，基于密钥的Hash算法，用公开函数和密钥产生一个固定长度认证标识，以鉴别消息的完整性，常用于登录鉴权。
- payload：token负载，部分用户信息以避免多次查库，少加敏感信息：
    - iss: token签发者。
    - iat: token的签发时间。
    - sub: 面向的用户。
    - aud: 接收token的一方。
    - exp: 定义token过期时间戳。
    - nbf: 定义token生效时间戳。
    - jti: token的id，主要用来作为一次性token。
- signature：使用header中声明的加密方式配合秘钥secret（保存在S端）形成字符串：
    - `HMAC(base64(header).base64(payload), secret)`
- JWT校验流程：    
    - B端首次登录成功时，S端将某些用户信息组合加密成一个token返回B端。
    - B端将该token保存在cookie，sessionStorage或localStorage中。
    - 后续B端请求均携带此token，S端解密成功时执行请求，否则阻止。

**流程：**
- 配置pom依赖：`jjwt`
- 开发实体类 `c.j.s.jwt.User`
- 开发JWT工具 `c.j.s.jwt.JwtUtil`
- 开发测试类 `c.j.s.jwt.JwtTest`

## 7.1 springboot 整合jwt

主要流程:
1.从 http 请求头中取出 token，
2.判断是否映射到方法
3.检查是否有passtoken注释，有则跳过认证
4.检查有没有需要用户登录的注解，有则需要取出并验证
5.认证通过则可以访问，不通过会报相关错误信息

引入JWT依赖
```xml
<dependency>
  <groupId>com.auth0</groupId>
  <artifactId>java-jwt</artifactId>
  <version>3.4.0</version>
</dependency>
```

源码：自定义注解PassToken，用来使类或者跳过token验证，毕竟不是所有方法都需要token验证。

```java
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface PassToken {
    boolean required() default true;
}
```

源码：自定义注解PassToken，带此注解的方法需要先验证是否已经登录
```java
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface UserLoginToken {
    boolean required() default true;
}
```

源码：User.java
```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class User {
    String id;
    String username;
    String password;
    String avatar;
}
```

接下来需要写一个拦截器去获取token并验证token
```java
/**
 * @author JoeZhou
 */
public class AuthenticationInterceptor implements HandlerInterceptor {

    @Autowired
    UserService userService;

    @Override
    public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object object) throws Exception {

        // 如果不是映射到方法直接通过
        if (!(object instanceof HandlerMethod)) {
            return true;
        }

        HandlerMethod handlerMethod = (HandlerMethod) object;
        Method method = handlerMethod.getMethod();

        // 如果方法上有 @PassToken，跳过认证，直接放行
        if (method.isAnnotationPresent(PassToken.class)) {
            return true;
        }

        // 如果方法上有 @UserLoginToken，执行认证
        if (method.isAnnotationPresent(UserLoginToken.class)) {
            UserLoginToken userLoginToken = method.getAnnotation(UserLoginToken.class);
            // 从请求头中取出 token
            String token = httpServletRequest.getHeader("token");
            if (token == null) {
                throw new RuntimeException("无token，请重新登录");
            }
            // 获取 token 中的 user id
            int id;
            try {
                id = Integer.parseInt(JWT.decode(token).getAudience().get(0));
            } catch (JWTDecodeException j) {
                // 获取id失败
                throw new RuntimeException("401");
            }
            User user = userService.findById(id);
            if (user == null) {
                throw new RuntimeException("用户不存在，请重新登录");
            }
            // 验证 token
            JWTVerifier jwtVerifier = JWT.require(Algorithm.HMAC256(user.getPassword())).build();
            try {
                jwtVerifier.verify(token);
            } catch (JWTVerificationException e) {
                throw new RuntimeException("401");
            }
            return true;

        }

        // 如果方法上没有上述两个注解，放行
        return true;
    }
}
```

配置拦截器
在配置类上添加了注解@Configuration，标明了该类是一个配置类并且会将该类作为一个SpringBean添加到IOC容器内

```java
/**
 * @author JoeZhou
 */
@Configuration
public class InterceptorConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // 拦截所有请求，通过判断是否有 @LoginRequired 注解 决定是否需要登录
        registry.addInterceptor(authenticationInterceptor())
                .addPathPatterns("/**");
    }
    @Bean
    public AuthenticationInterceptor authenticationInterceptor() {
        return new AuthenticationInterceptor();
    }
}
```

源码：UserService.java
```java
/**
 * @author JoeZhou
 */
public interface UserService {
    /**
     * 通过id查找用户
     * @param id 主键
     * @return 对应主键的用户
     */
    User findById(int id);
}
```

源码：UserServiceImp.java
```java
@Service
public class UserServiceImpl implements UserService {
    @Override
    public User findById(int id) {
        User user = new User();
        user.setId(1);
        user.setUsername("joezhou");
        user.setPassword("123");
        user.setAvatar("joezhou.jpg");
        return id == 1 ? user : null;
    }
}
```

源码：UserController.java
```java
@RestController
@RequestMapping("/api/user")
public class UserController {
    @Autowired
    UserService userService;

    @RequestMapping("/login")
    public String login(@RequestParam("id") int id, @RequestParam("password") String password) {
        User user = userService.findById(id);
        if (user == null) {
            return "登录失败，用户不存在";
        } else {
            // 登录成功
            if (!user.getPassword().equals(password)) {
                return "登录失败,密码错误";
            } else {
                String token = JWT.create().withAudience(user.getId().toString())
                        .sign(Algorithm.HMAC256(user.getPassword()));
                return "token: " + token
                        + " id: " + user.getId()
                        + " password: " + user.getPassword()
                        + " avatar: " + user.getAvatar();
            }
        }
    }

    @UserLoginToken
    @GetMapping("/getMessage")
    public String getMessage() {
        return "你已通过验证";
    }
}
```

> 不加注解的话默认不验证，登录接口一般是不验证的。在getMessage()中我加上了登录注解，说明该接口必须登录获取token后，在请求头中加上token并通过验证才可以访问

测试：
- psm: `{{local}}/api/user/getMessage`，不添加token，登录失败，控制台抛出异常。
- psm：`{{local}}/api/user/login` 登录，该方法没有@UserLoginToken注解，直接放行，登录成功，返回token
- psm：`{{local}}/api/user/getMessage`，不添加token，同时请求头加如登录成功后的那个token，通过验证。









 



