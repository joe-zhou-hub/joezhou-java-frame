# 1. Servlet原生组件
     
**概念：** springboot支持原生的servlet组件，如servlet过滤器和servlet监听器等：
- 开发原生servlet类 `c.j.s.servlet.BeanServlet`，无需添加注解。
- 开发原生过滤器类 `c.j.s.servlet.filter.BeanFilter`，无需添加注解。
- 开发原生监听器类 `c.j.s.servlet.listener.BeanListener`，无需添加注解。
- 开发配置类 `c.j.s.servlet.BeanServletConfig`：
    - IOC `o.s.b.w.s.ServletRegistrationBean` 类，利用构造传入servlet实例和路由。
- 开发配置类 `c.j.s.servlet.filter.BeanFilterConfig`：
    - IOC `o.s.b.w.s.FilterRegistrationBean` 过滤器链类。
    - `filters.setFilter()`：在过滤器链中加入自定义过滤器。
    - `filters.addUrlPatterns()`：在过滤器链中加入自定义过滤器拦截规则。
- 开发配置类 `c.j.s.servlet.listener.BeanListenerConfig`：
    - IOC `o.s.b.w.s.ServletListenerRegistrationBean` 监听器类，利用构造传入监听器实例。
    - 每个监听对应一个 `@Bean`。
- psm测试：`/api/servlet/bean`。

## 1.1 注解配置方案

**流程：** 
- 开发原生servlet类 `c.j.s.servlet.ScanServlet`，标记 `@WebServlet`。
- 开发原生过滤器类 `c.j.s.servlet.filter.ScanFilter`，标记 `@WebFilter`。
- 开发原生监听器类 `c.j.s.servlet.listener.ScanListener`，标记 `@WebListener`。
- 在启动类中使用 `@ServletComponentScan` 扫描servlet类，过滤器类和监听器类所在包。
- psm测试：`/api/servlet/scan`。

## 1.2 同时配置方案

**流程：** 
- 开发原生servlet类 `c.j.s.servlet.ContextServlet`，无需添加注解。
- 开发原生过滤器类 `c.j.s.servlet.filter.ContextFilter`，无需添加注解。
- 开发原生监听器类 `c.j.s.servlet.listener.ContextListener`，无需添加注解。
- 让启动类实现 `ServletContextInitializer` 接口并重写 `onStartup()`：
    - `context.addServlet().addMapping()`：配置servlet类并设置路由。
    - `context.addFilter().addMappingForUrlPatterns()`：配置过滤器类并设置拦截规则。
    - `context.addListener()`：配置监听器类。
- psm测试：`/api/servlet/context`。

# 2. Spring拦截器

**流程：** 
- 配置pom依赖 `spring-boot-starter-aop`。
- 开发切面配置类 `c.j.s.aop.AopAspect`：标记 `@Aspect` 和 `@Configuration`。
    - 开发通知方法：如环绕通知 `@Around("execution()")`。
- 开发动作类 `c.j.s.aop.AopController`。
- psm测试：`/api/aop/execute`。

# 3. 全局异常

**概念：** 全局异常处理类的优先级低于异常通知，二者共存时，可以在异常通知处理中直接return错误信息，同样会返回给B端：
- 开发全局异常处理类 `c.j.s.exception.GlobalException`：标记 `@ControllerAdvice`：
    - 异常处理方法标记 `@ExceptionHandler` 以指定捕获哪些异常。
    - 异常处理方法标记 `@ResponseBody` 以返回异常信息内容。
- 开发动作类 `c.j.s.exception.ExceptionController`：开发一个会爆发异常的动作方法。
- psm测试：`/api/exception/execute`。

# 4. 定时任务

**概念：** springboot内置 `@EnableScheduling` 以替代 `java.util.Timer/TimerTask` 完成定时任务：
- 启动类标记 `@EnableScheduling` 以开启定时功能。
- 开发任务类 `c.j.s.schedule.ScheduleTask`：标记 `@Component` 以被spring管理。
- 开发任务方法并标记 `@Scheduled`：
    - `cron`：[CRON表达式](https://baike.baidu.com/item/cron)
    - `fixedDelay=1000`：立即执行任务，每次任务完成后计时，每隔1秒执行一次任务。
    - `fixedRate=1000`：立即执行任务，每次任务开始前计时，每隔1秒执行一次任务。
- 启动入口类，控制台观测任务执行情况。

# 5. 异步处理

**概念：** 异步执行方法不占用主线程资源，可以提高项目执行效率：
- 启动类上添加 `@EnableAsync` 开启异步功能。
- 开发任务类 `c.j.s.async.AsyncTask`：标记 `@Component` 被spring管理。
- 开发三个任务方法，分别模拟耗时1s/2s/3s：标记 `@Async` 以异步调用：
    - 若任务类中所有方法都是异步调用，则可将 `@Async` 标记在类上。
    - 方法返回值可封装在实现了 `Future` 接口的 `AsyncResult` 类中。
- 开发动作类 `c.j.s.async.AsyncController`：依次调用任务方法：
    - 对返回值调用 `get()` 可以获取任务方法的返回值。
    - 对返回值调用 `isDone()` 可以判断任务是否已完成。
- psm：`api/async/execute`。

# 6. 响应式编程

**概念：** [webflux](https://docs.spring.io/spring-boot/docs/2.3.1.RELEASE/reference/html/spring-boot-features.html#boot-features-webflux) 是Spring5中的异步非阻塞响应式编程框架，不依赖servlet，不能部署为war包，不使用webapp目录，请求响应对象使用 `ServletRequest/ServletResponse`：
- 异步：事件互相之间不干扰，以提升复杂请求业务的性能。
- 非阻塞：数据以流的形式响应，可利用较少的线程数或硬件资源来处理任务，进而提伸缩性。
- 响应式编程：在有限的资源下提高系统的伸缩性，但不会让程序运行的更快：
    - `z-res/响应式编程举例.md`
- 创建springboot-jar项目 `springboot2-webflux`，选择 `Web/Spring Reactive Web` 依赖：
    - 手动配置需要添加pom依赖 `spring-boot-starter-webflux/reactor-test`。
    - `spring-boot-starter-webflux` 比 `spring-boot-starter-web` 优先级低，共存时失效。
- 启动入口类：启动方式由tomcat同步容器变为netty异步容器时表示成功引入webflux。
- 开发实体类 `c.j.s.pojo.User`。
- 开发业务接口 `c.j.s.service.UserService`：
    - 使用 `Mono<User>` 异步不阻塞返回单条User数据。
    - 使用 `Flux<User>` 异步不阻塞返回多条User数据。
- 开发业务类 `c.j.s.service.impl.UserServiceImpl`：
    - `Mono.just(user)`：返回 `Mono` 对象，参数为null或空时抛异常。
    - `Mono.justOrEmpty(user)`：返回 `Mono` 对象，参数为null或空时返回 `MonoEmpty` 对象。
    - `Flux.fromIterable(users)`：返回 `Flux` 集合对象。
    - `Flux.fromArray(users)`：返回 `Flux` 数组对象。
- 开发动作类 `c.j.s.controller.UserController`：动作方法可直接返回 `Mono/Flux` 对象。
    - `@RequestMaping` 配置 `produces="application/stream+json"` 可以开启流响应。
    - 对Flux数据调用 `delayElements(Duration.ofSeconds(2))` 可以设置响应流速为2秒一次。
- psm测试 `api/user/select-by-id`。
- cli测试 `api/user/select-all`，postman无法观察流响应效果。
- 开发WebClient类 `c.j.s.user.UserTest`：用于模拟发送webflux请求，必须先手动启动项目后测试：
    - `WebClient.create("uri").get()/post()`：创建并配置webflux的get/post请求。
    - `retrieve().bodyToMono/bodyToFlux(User.class)`：将User数据提取到Mono/Flux对象中。
    - `mono.block()`：立刻取出Mono中的数据。
    - `flux.collectList().block()`：将Flux中的数据收集到list中。

# 7. JWT校验

**概念：** JWT（Json Web Token）是一个开放标准，定义了一种用于简洁，自身包含的用于通信双方之间以Json对象的形式安全传递信息的方法，JWT可以使用HMAC算法或者是RSA的公钥密钥进行签名：就是通过一定规范来生成token，然后可以通过解密算法解密token，以获取用户信息。
- token可以包含基本信息，比如id，用户昵称，头像等，避免二次查库。
- token存储在客户端cookie，sessionStorage或者localStorage里面，不占用服务器资源。
- token是经过base64编码的，可以在客户端被破解，故不要加入敏感信息。  
- JWT组成：一个JWT由头部，负载和签名组成：
    - 头部header：描述基本加密算法。
    - 负载payload：描述加密对象的信息，如id，头像，昵称等，包含用户的基本定义信息，约定，iss签发者，exp过期时间，sub面向的用户等。
    - 签名signature：将header和payload进行组合并加密。
- token格式：aaa.bbb.cc 对应 头.负载.签名

**流程：**
- 用户在某个节点第一次登录成功时，将某些关键信息组合加密，形成一个token，保存在客户端。
- 后续用户在任何节点登录时都要带着这个token字符串。
- 后台解密token，发现解密成功，允许执行，否则阻止。


JWT官网： https://jwt.io/
JWT(Java版)的github地址:https://github.com/jwtk/jjwt

什么是JWT
Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).定义了一种简洁的，自包含的方法用于通信双方之间以JSON对象的形式安全的传递信息。因为数字签名的存在，这些信息是可信的，JWT可以使用HMAC算法或者是RSA的公私秘钥对进行签名。

JWT请求流程
image.png
1. 用户使用账号和面发出post请求；
2. 服务器使用私钥创建一个jwt；
3. 服务器返回这个jwt给浏览器；
4. 浏览器将该jwt串在请求头中像服务器发送请求；
5. 服务器验证该jwt；
6. 返回响应的资源给浏览器。

JWT的主要应用场景
身份认证在这种场景下，一旦用户完成了登陆，在接下来的每个请求中包含JWT，可以用来验证用户身份以及对路由，服务和资源的访问权限进行验证。由于它的开销非常小，可以轻松的在不同域名的系统中传递，所有目前在单点登录（SSO）中比较广泛的使用了该技术。 信息交换在通信的双方之间使用JWT对数据进行编码是一种非常安全的方式，由于它的信息是经过签名的，可以确保发送者发送的信息是没有经过伪造的。

优点
1.简洁(Compact): 可以通过URL，POST参数或者在HTTP header发送，因为数据量小，传输速度也很快
2.自包含(Self-contained)：负载中包含了所有用户所需要的信息，避免了多次查询数据库
3.因为Token是以JSON加密的形式保存在客户端的，所以JWT是跨语言的，原则上任何web形式都支持。
4.不需要在服务端保存会话信息，特别适用于分布式微服务。

`

JWT的结构
JWT是由三段信息构成的，将这三段信息文本用.连接一起就构成了JWT字符串。
就像这样:
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ

JWT包含了三部分：
Header 头部(标题包含了令牌的元数据，并且包含签名和/或加密算法的类型)
Payload 负载 (类似于飞机上承载的物品)
Signature 签名/签证

Header
JWT的头部承载两部分信息：token类型和采用的加密算法。

{ 
  "alg": "HS256",
   "typ": "JWT"
} 
声明类型:这里是jwt
声明加密的算法:通常直接使用 HMAC SHA256

加密算法是单向函数散列算法，常见的有MD5、SHA、HAMC。
MD5(message-digest algorithm 5) （信息-摘要算法）缩写，广泛用于加密和解密技术，常用于文件校验。校验？不管文件多大，经过MD5后都能生成唯一的MD5值
SHA (Secure Hash Algorithm，安全散列算法），数字签名等密码学应用中重要的工具，安全性高于MD5
HMAC (Hash Message Authentication Code)，散列消息鉴别码，基于密钥的Hash算法的认证协议。用公开函数和密钥产生一个固定长度的值作为认证标识，用这个标识鉴别消息的完整性。常用于接口签名验证

Payload
载荷就是存放有效信息的地方。
有效信息包含三个部分
1.标准中注册的声明
2.公共的声明
3.私有的声明

标准中注册的声明 (建议但不强制使用) ：
iss: jwt签发者
sub: 面向的用户(jwt所面向的用户)
aud: 接收jwt的一方
exp: 过期时间戳(jwt的过期时间，这个过期时间必须要大于签发时间)
nbf: 定义在什么时间之前，该jwt都是不可用的.
iat: jwt的签发时间
jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。

公共的声明 ：
公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密.

私有的声明 ：
私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。

Signature
jwt的第三部分是一个签证信息
这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串，然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分。
密钥secret是保存在服务端的，服务端会根据这个密钥进行生成token和进行验证，所以需要保护好。

作者：意识流丶
链接：https://www.jianshu.com/p/e88d3f8151db
来源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


# 封装JWT工具类

引入依赖
```pom
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt</artifactId>
    <version>0.7.0</version>
</dependency>
```

```java
/**
 * @author JoeZhou
 */
@Data
public class User{
    private Integer id;
    private String username;
    private String avatar;
}
```

```java
/**
 * @author JoeZhou
 */
public class JwtTool {

    // 发行者
    public static final String SUBJECT = "joezhou";

    // 过期时间一周
    public static Long EXPIRE = 1000 * 60 * 60 * 24 * 7L;

    // 密钥：不能暴露
    public static String APPSECRET = "yy06200210";

    /*对User中的ID，用户名和头像进行加密*/
    public static String geneJwt(User user) {
        if (user == null || user.getId() == null || user.getUsername() == null || user.getAvatar() == null) {
            return null;
        }
        String token = Jwts.builder().setSubject(SUBJECT)
                .claim("id", user.getId())
                .claim("username", user.getUsername())
                .claim("avatar", user.getAvatar())
                .setIssuedAt(new Date())// 发行时间
                .setExpiration(new Date(System.currentTimeMillis() + EXPIRE))// 过期时间
                .signWith(SignatureAlgorithm.HS256, APPSECRET)// 定义密钥
                .compact();
        return token;
    }

    /*解密*/
    public static Claims checkJwt(String token) {
        final Claims claims;
        try {
            // 获取payload
            claims = Jwts.parser()
                    .setSigningKey(APPSECRET).parseClaimsJws(token).getBody();
        } catch (Exception e) {
            return null;
        }
        return claims;
    }
}
```

```java
/**
 * @author JoeZhou
 */
public class JwtTest {

    @Test
    public void geneJwt() {
        User user = new User();
        user.setId(999);
        user.setAvatar("joe.jpg");
        user.setUsername("joezhou");

        String token = JwtTool.geneJwt(user);
        System.out.println(token);
    }

    @Test
    public void checkJwt() {
        // 将上一个方法生成的token拿过来
        // 这个字符串稍微改动一点都会返回一个null的Claims
        String token = "eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJqb2V6aG91IiwiaWQiOjk5OSwidXNlcm5hbWUiOiJqb2V6aG91IiwiYXZhdGFyIjoiam9lLmpwZyIsImlhdCI6MTYwNjk2NTI4NiwiZXhwIjoxNjA3NTcwMDg2fQ.MfnBGV-M3P5Uz1YZJ8DtRCV0858WS3mrZMutaOwAWyU";
        Claims claims = JwtTool.checkJwt(token);
        if (claims != null) {
            Integer id = (Integer) claims.get("id");
            String username = (String) claims.get("username");
            String avatar = (String) claims.get("avatar");
            System.out.println(id);
            System.out.println(username);
            System.out.println(avatar);
        } else {
            System.out.println("非法token");
        }
    }
}
```

# springboot 整合jwt

主要流程:
1.从 http 请求头中取出 token，
2.判断是否映射到方法
3.检查是否有passtoken注释，有则跳过认证
4.检查有没有需要用户登录的注解，有则需要取出并验证
5.认证通过则可以访问，不通过会报相关错误信息

引入JWT依赖
```xml
<dependency>
  <groupId>com.auth0</groupId>
  <artifactId>java-jwt</artifactId>
  <version>3.4.0</version>
</dependency>
```

源码：自定义注解PassToken，用来使类或者跳过token验证，毕竟不是所有方法都需要token验证。
```java
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface PassToken {
    boolean required() default true;
}
```

源码：自定义注解PassToken，带此注解的方法需要先验证是否已经登录
```java
@Target({ElementType.METHOD, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
public @interface UserLoginToken {
    boolean required() default true;
}
```

源码：User.java
```java
@Data
@AllArgsConstructor
@NoArgsConstructor
public class User {
    String id;
    String username;
    String password;
    String avatar;
}
```

接下来需要写一个拦截器去获取token并验证token
```java
/**
 * @author JoeZhou
 */
public class AuthenticationInterceptor implements HandlerInterceptor {

    @Autowired
    UserService userService;

    @Override
    public boolean preHandle(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object object) throws Exception {

        // 如果不是映射到方法直接通过
        if (!(object instanceof HandlerMethod)) {
            return true;
        }

        HandlerMethod handlerMethod = (HandlerMethod) object;
        Method method = handlerMethod.getMethod();

        // 如果方法上有 @PassToken，跳过认证，直接放行
        if (method.isAnnotationPresent(PassToken.class)) {
            return true;
        }

        // 如果方法上有 @UserLoginToken，执行认证
        if (method.isAnnotationPresent(UserLoginToken.class)) {
            UserLoginToken userLoginToken = method.getAnnotation(UserLoginToken.class);
            // 从请求头中取出 token
            String token = httpServletRequest.getHeader("token");
            if (token == null) {
                throw new RuntimeException("无token，请重新登录");
            }
            // 获取 token 中的 user id
            int id;
            try {
                id = Integer.parseInt(JWT.decode(token).getAudience().get(0));
            } catch (JWTDecodeException j) {
                // 获取id失败
                throw new RuntimeException("401");
            }
            User user = userService.findById(id);
            if (user == null) {
                throw new RuntimeException("用户不存在，请重新登录");
            }
            // 验证 token
            JWTVerifier jwtVerifier = JWT.require(Algorithm.HMAC256(user.getPassword())).build();
            try {
                jwtVerifier.verify(token);
            } catch (JWTVerificationException e) {
                throw new RuntimeException("401");
            }
            return true;

        }

        // 如果方法上没有上述两个注解，放行
        return true;
    }
}
```

配置拦截器
在配置类上添加了注解@Configuration，标明了该类是一个配置类并且会将该类作为一个SpringBean添加到IOC容器内

```java
/**
 * @author JoeZhou
 */
@Configuration
public class InterceptorConfig implements WebMvcConfigurer {
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        // 拦截所有请求，通过判断是否有 @LoginRequired 注解 决定是否需要登录
        registry.addInterceptor(authenticationInterceptor())
                .addPathPatterns("/**");
    }
    @Bean
    public AuthenticationInterceptor authenticationInterceptor() {
        return new AuthenticationInterceptor();
    }
}
```

源码：UserService.java
```java
/**
 * @author JoeZhou
 */
public interface UserService {
    /**
     * 通过id查找用户
     * @param id 主键
     * @return 对应主键的用户
     */
    User findById(int id);
}
```

源码：UserServiceImp.java
```java
@Service
public class UserServiceImpl implements UserService {
    @Override
    public User findById(int id) {
        User user = new User();
        user.setId(1);
        user.setUsername("joezhou");
        user.setPassword("123");
        user.setAvatar("joezhou.jpg");
        return id == 1 ? user : null;
    }
}
```

源码：UserController.java
```java
@RestController
@RequestMapping("/api/user")
public class UserController {
    @Autowired
    UserService userService;

    @RequestMapping("/login")
    public String login(@RequestParam("id") int id, @RequestParam("password") String password) {
        User user = userService.findById(id);
        if (user == null) {
            return "登录失败，用户不存在";
        } else {
            // 登录成功
            if (!user.getPassword().equals(password)) {
                return "登录失败,密码错误";
            } else {
                String token = JWT.create().withAudience(user.getId().toString())
                        .sign(Algorithm.HMAC256(user.getPassword()));
                return "token: " + token
                        + " id: " + user.getId()
                        + " password: " + user.getPassword()
                        + " avatar: " + user.getAvatar();
            }
        }
    }

    @UserLoginToken
    @GetMapping("/getMessage")
    public String getMessage() {
        return "你已通过验证";
    }
}
```

> 不加注解的话默认不验证，登录接口一般是不验证的。在getMessage()中我加上了登录注解，说明该接口必须登录获取token后，在请求头中加上token并通过验证才可以访问

测试：
- psm: `{{local}}/api/user/getMessage`，不添加token，登录失败，控制台抛出异常。
- psm：`{{local}}/api/user/login` 登录，该方法没有@UserLoginToken注解，直接放行，登录成功，返回token
- psm：`{{local}}/api/user/getMessage`，不添加token，同时请求头加如登录成功后的那个token，通过验证。









 



