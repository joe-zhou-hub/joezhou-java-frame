# 1. Servlet原生组件
     
**概念：** springboot支持原生的servlet组件，如servlet过滤器和servlet监听器等：
- 开发原生servlet类 `c.j.s.servlet.BeanServlet`，无需添加注解。
- 开发原生过滤器类 `c.j.s.servlet.filter.BeanFilter`，无需添加注解。
- 开发原生监听器类 `c.j.s.servlet.listener.BeanListener`，无需添加注解。
- 开发配置类 `c.j.s.servlet.BeanServletConfig`：
    - IOC `o.s.b.w.s.ServletRegistrationBean` 类，利用构造传入servlet实例和路由。
- 开发配置类 `c.j.s.servlet.filter.BeanFilterConfig`：
    - IOC `o.s.b.w.s.FilterRegistrationBean` 过滤器链类。
    - `filters.setFilter()`：在过滤器链中加入自定义过滤器。
    - `filters.addUrlPatterns()`：在过滤器链中加入自定义过滤器拦截规则。
- 开发配置类 `c.j.s.servlet.listener.BeanListenerConfig`：
    - IOC `o.s.b.w.s.ServletListenerRegistrationBean` 监听器类，利用构造传入监听器实例。
    - 每个监听对应一个 `@Bean`。
- psm测试：`/api/servlet/bean`。

## 1.1 注解配置方案

**流程：** 
- 开发原生servlet类 `c.j.s.servlet.ScanServlet`，标记 `@WebServlet`。
- 开发原生过滤器类 `c.j.s.servlet.filter.ScanFilter`，标记 `@WebFilter`。
- 开发原生监听器类 `c.j.s.servlet.listener.ScanListener`，标记 `@WebListener`。
- 在启动类中使用 `@ServletComponentScan` 扫描servlet类，过滤器类和监听器类所在包。
- psm测试：`/api/servlet/scan`。

## 1.2 同时配置方案

**流程：** 
- 开发原生servlet类 `c.j.s.servlet.ContextServlet`，无需添加注解。
- 开发原生过滤器类 `c.j.s.servlet.filter.ContextFilter`，无需添加注解。
- 开发原生监听器类 `c.j.s.servlet.listener.ContextListener`，无需添加注解。
- 让启动类实现 `ServletContextInitializer` 接口并重写 `onStartup()`：
    - `context.addServlet().addMapping()`：配置servlet类并设置路由。
    - `context.addFilter().addMappingForUrlPatterns()`：配置过滤器类并设置拦截规则。
    - `context.addListener()`：配置监听器类。
- psm测试：`/api/servlet/context`。

# 2. Spring拦截器

**流程：** 
- 配置pom依赖 `spring-boot-starter-aop`。
- 开发切面配置类 `c.j.s.aop.AopAspect`：标记 `@Aspect` 和 `@Configuration`。
    - 开发通知方法：如环绕通知 `@Around("execution()")`。
- 开发动作类 `c.j.s.aop.AopController`。
- psm测试：`/api/aop/execute`。

# 3. 全局异常

**概念：** 全局异常处理类的优先级低于异常通知，二者共存时，可以在异常通知处理中直接return错误信息，同样会返回给B端：
- 开发全局异常处理类 `c.j.s.exception.GlobalException`：标记 `@ControllerAdvice`：
    - 异常处理方法标记 `@ExceptionHandler` 以指定捕获哪些异常。
    - 异常处理方法标记 `@ResponseBody` 以返回异常信息内容。
- 开发动作类 `c.j.s.exception.ExceptionController`：开发一个会爆发异常的动作方法。
- psm测试：`/api/exception/execute`。

# 4. 定时任务

**概念：** springboot内置 `@EnableScheduling` 以替代 `java.util.Timer/TimerTask` 完成定时任务：
- 启动类标记 `@EnableScheduling` 以开启定时功能。
- 开发任务类 `c.j.s.schedule.ScheduleTask`：标记 `@Component` 以被spring管理。
- 开发任务方法并标记 `@Scheduled`：
    - `cron`：[CRON表达式](https://baike.baidu.com/item/cron)
    - `fixedDelay=1000`：立即执行任务，每次任务完成后计时，每隔1秒执行一次任务。
    - `fixedRate=1000`：立即执行任务，每次任务开始前计时，每隔1秒执行一次任务。
- 启动入口类，控制台观测任务执行情况。

# 5. 异步处理

**概念：** 异步执行方法不占用主线程资源，可以提高项目执行效率：
- 启动类上添加 `@EnableAsync` 开启异步功能。
- 开发任务类 `c.j.s.async.AsyncTask`：标记 `@Component` 被spring管理。
- 开发三个任务方法，分别模拟耗时1s/2s/3s：标记 `@Async` 以异步调用：
    - 若任务类中所有方法都是异步调用，则可将 `@Async` 标记在类上。
    - 方法返回值可封装在实现了 `Future` 接口的 `AsyncResult` 类中。
- 开发动作类 `c.j.s.async.AsyncController`：依次调用任务方法：
    - 对返回值调用 `get()` 可以获取任务方法的返回值。
    - 对返回值调用 `isDone()` 可以判断任务是否已完成。
- psm：`api/async/execute`。

# 6. 响应式编程

**概念：** [webflux](https://docs.spring.io/spring-boot/docs/2.3.1.RELEASE/reference/html/spring-boot-features.html#boot-features-webflux) 是Spring5中的异步非阻塞响应式编程框架，不依赖servlet，不能部署为war包，不使用webapp目录，请求响应对象使用 `ServletRequest/ServletResponse`：
- 异步：事件互相之间不干扰，以提升复杂请求业务的性能。
- 非阻塞：数据以流的形式响应，可利用较小的线程或硬件资源来处理任务，进而提高任务可伸缩性。
- 响应式编程：在有限的资源下提高系统的伸缩性，但可能不会让程序运行的更快：
    - `z-res/响应式编程举例.md`
- 创建springboot-jar项目 `springboot2-webflux`，选择 `Web/Spring Reactive Web` 依赖：
    - 手动配置需要添加pom依赖 `spring-boot-starter-webflux/reactor-test`。
    - `spring-boot-starter-webflux` 比 `spring-boot-starter-web` 优先级低，共存时失效。
- 启动入口类：启动方式由tomcat变为netty时表示成功引入webflux。
- 开发实体类 `c.j.s.pojo.User`。
- 开发业务接口 `c.j.s.service.UserService`：
    - 使用 `Mono<User>` 异步不阻塞返回单条数据。
    - 使用 `Flux<User>` 异步不阻塞返回多条数据。
- 开发业务类 `c.j.s.service.impl.UserServiceImpl`：
    - `Mono.just(user)`：返回 `Mono<User>` 对象，参数为null或空时抛异常。
    - `Mono.justOrEmpty(user)`：返回 `Mono<User>` 对象，参数为null或空时返回 `MonoEmpty` 对象。
    - `Flux.fromIterable(users)`：返回一个 `Flux<User>` 对象，表示可迭代集合对象。
    - `Flux.fromArray(users)`：返回一个 `Flux<User>` 对象，表示可迭代数组对象。
- 开发动作类 `c.j.s.controller.UserController`：动作方法可直接返回 `Mono/Flux` 对象。
- psm测试 `api/user/select-by-id`，`api/user/select-all`

# 7. 流数据形式的返回

**概念：** 我们可以更改动作方法来让数据以流的形式返回给调用方。
- `produces = MediaType.APPLICATION_STREAM_JSON_VALUE`：声明响应数据类型为JSON流。
- `delayElements(Duration.ofSeconds(2))`：控制响应数据的时间间隔为2秒。

**源码：** 修改UserController.java中的retrieveAll方法：
```java
@RequestMapping(value = "/retrieve-all.action", produces = MediaType.APPLICATION_STREAM_JSON_VALUE)
public Flux<User> retrieveAll() {
    return userService.retrieveAll().delayElements(Duration.ofSeconds(2));
}
```

> 测试接口：./api/user/retrieve-all.action

# 8. 客户端webClient

**概念：** `webClient` 是 `webflux` 的一个WEB客户端，即可以使用junit来模拟一次WEB请求。
- `create()`：创建一个WebClient对象。
- `get()`：设置模拟请求为GET方式，可以选用 `post()` / `delete()` 等。
- `uri()`：设置模拟的请求地址，查询串可以使用占位符 `?id={id}`，然后 `uri()` 第二参数为不定长参数，可以补充占位。
- `accept()`：设置可接受响应数据类型。
- `retrieve()`：查询响应体数据。
- `bodyToMono(User.class)`：将User类型的响应体数据提取到Mono。
- `block()`：阻塞Mono，立刻取出数据。

**源码：** WebClientTest.java
```java
/**
 * @author JoeZhou
 */
class WebClientTest {

    @Test
    void webClient() {
        String uri = "http://localhost:8080/api/user/retrieve-by-id.action?id=1";
        Mono<User> userMono = WebClient
                .create()
                .get()
                .uri(uri)
                .accept(MediaType.APPLICATION_JSON)
                .retrieve().bodyToMono(User.class);
        User user = userMono.block();
        System.out.println(user);
    }
}
```

> 运行测试类之前，需要先启动启动类，否则接口发送不成功。










 



