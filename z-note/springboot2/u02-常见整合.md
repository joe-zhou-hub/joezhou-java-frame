# 1. 整合LogBack

**概念：** `spring-boot-starter` 依赖中包含了 `spring-boot-starter-logging` 依赖，即springboot默认使用logback作为日志框架，它是log4j的改进版，不能单独使用，推荐配合slf4j一起使用：
- springboot默认加载 `classpath:logback.xml` 或 `classpath:logback-spring.xml`：
- 自定义日志配置文件需要在主配文件中指定：`logging.config=classpath:console-log.xml`。
- 日志级别：TRACE < DEBUG < INFO < WARN < ERROR < ALL，不区分大小写。

**流程：** 将日志打印在控制台：
- 配置控制台追加器 `<appender name="STDOUT" class="c.q.l.c.ConsoleAppender>`：
    - `<encoder>` + `<pattern>/<charset>`：配置日志格式/字符集。
- 配置根记录器 `<root level="INFO">`：仅记录INFO及以上级别的启动日志和运行时日志：
    - `<appender-ref>` 使用 `ref` 属性关联某个追加器名，表示使用该追加器，可存在0或多个。
- 开发动作类并通过 `LoggerFactory.getLogger(getClass())` 获取当前类的 `Logger` 实例：
    - `logger.debug/info/warn/error("")`：记录一条DEBUG/INFO/WARN/ERROR级别的日志信息。

**流程：** 将日志输出到日志文件：
- 配置文件追加器 `<appender name="INFO" class="c.q.l.c.r.RollingFileAppender">`：
    - `<encoder>` + `<pattern>/<charset>`：配置日志格式/字符集。
    - `<file>`：指定日志文件路径，默认位置相对于所在项目，支持使用绝对路径。
    - `<append>`：设置是否追加日志，默认为true。
- 配置过滤器：`<filter class="c.q.l.c.f.LevelFilter">`：
    - `<level>ERROR</level>`：指定参考日志等级为ERROR。
    - `<onMatch>DENY</onMatch>`：ERROR级别日志阻止记录。
    - `<onMismatch>ACCEPT</onMismatch>`：除ERROR之外的级别日志允许记录。
- 配置滚动策略：`<rollingPolicy class="c.q.l.c.r.SizeAndTimeBasedRollingPolicy">`：
    - 策略：先将日志记录到日志文件中，如 `my.log`：
        - 日期变化时将昨天的日志文件重命名为 `my.日期.1.log`，今天的日志文件名仍用 `my.log`。
        - 日志文件超过拆分阈值时，将 `my.log` 拆为 `my.日期.1.log` 和 `my.日期.2.log`。
    - `<fileNamePattern>`：日志文件格式，建议使用 `log/warn.%d.%i.log`。
    - `<maxHistory>`：日志文件最长时效，单位根据 `<fileNamePattern>` 自动识别。
    - `<totalSizeCap>`：全部日志文件最大值，如 `10GB`，超出 `10GB` 立刻删除多余日志。
    - `<maxFileSize>`：每个日志文件拆分阈值，默认 `10MB`，文件大小超过此值时进行切分。
- 配置运行时记录器：`<logger name="c.j.app" level="WARN">`：仅记录指定包中WARN及以上级别日志：
    - `<appender-ref>` 使用 `ref` 属性关联某个追加器名，表示使用该追加器，可存在0或多个。
    - `<logger>` 针对指定包进行日志记录，可存在多个，但无法记录启动日志，启动日志需使用根记日志录器。
- 开发动作类：并通过 `LoggerFactory.getLogger(getClass())` 获取当前类的 `Logger` 实例：
    - `logger.debug/info/warn/error("")`：记录一条DEBUG/INFO/WARN/ERROR级别的日志信息。

> z-res/logback-pattern.md

**源码：** /springboot2/
- res: `classpath:console-log.xml`
- res: `classpath:file-log.xml`
- src: `c.j.s.logback.LogBackController`
- psm: `api/logback/test`

# 2. 整合Thymeleaf

**概念：** Thymeleaf是一种模版引擎，能处理HTML，XML，TEXT，JAVASCRIPT和CSS模板内容，springboot默认会顺序从 `/META-INF/resources`，`classpath:/resources/`，`classpath:/static/`，`classpath:/public/` 中寻找资源，有则直接返回，若都没有404：
- 添加依赖：`spring-boot-starter-thymeleaf`
- 主配添加：
    - `spring.web.resources.static-locations`：默认静态资源加载位置。
    - `spring.thymeleaf.enabled`：启用thymeleaf，默认true。
    - `spring.thymeleaf.cache`：启用thymeleaf缓存，默认true
    - `spring.thymeleaf.prefix`：配置thymeleaf响应路径前缀，默认classpath:/templates/。
    - `spring.thymeleaf.suffix`：配置thymeleaf响应路径后缀，默认.html。
    - `spring.thymeleaf.encoding`：配置thymeleaf编码，默认UTF-8。
- 动作类开发：响应路径自动补充主配中thymeleaf的前后缀。
- 页面开发：
    - 在 `<html>` 中添加thymeleaf的命名空间：`xmlns:th="http://www.thymeleaf.org"`。
    - 在HTML标签中使用` th:text="${msg }"` 可取出请求域中的值，该值支持 `+` 或 `|` 进行字符拼接。
- 友好页面：支持在 `classpath:/public/error` 下创建如 `4xx.html` 的HTTP状态反馈页面，仅浏览器生效。

**源码：** /springboot2/
- res: `classpath:application.properties`
- src: `c.j.s.thymeleaf.ThymeleafController`
- web: `classpath:templates/thymeleaf-test.html`
- web: `classpath:public/error/4xx.html`
- web: `classpath:public/error/5xx.html`
- psm: `api/thymeleaf/test`

# 3. 整合MyBatis

**概念：** springboot支持原生JDBC，apache-dbutils，JPA，Hibernate，MyBatis等持久层框架：
- 添加依赖：`spring-boot-starter-jdbc/mybatis-spring-boot-starter/mysql-connector-java/druid`
- 主配添加：
    - `mybatis.mybatis.config-location`：配置mybatis主配文件位置，可忽略。
    - `mybatis.mapper-locations`：配置SQL配置文件位置（使用注解配置SQL可忽略此项）。
    - `mybatis.type-aliases-package`：别名包扫描。
    - `mybatis.configuration.log-impl=o.a.i.l.s.StdOutImpl`：控制台SQL。
    - `spring.datasource.driver-class-name/url/username/password`：数据源四项。
    - `spring.datasource.type`：连接池，默认 `c.z.h.HikariDataSource`。
- 开发ORM实体类，SQL配置文件（使用注解配置SQL可忽略此项）。
- 开发Mapper接口，需要标记 `@Repository`，junit测试。
- 开发业务层，需要标记 `@Service`，junit测试。
- 开发控制层，需要标记 `@Controller`。
- 入口类：使用 `@MapperScan` 包扫描Mapper接口包以替代对每个Mapper接口标记 `@Mapper`：
    - `@MapperScan` 包扫描需要指定到具体的mapper包（非父包），且包中不要存在其他接口。

**源码：** /springboot2/
- res: `README.md`
- res: `springboot.sql`
- res: `classpath:application.properties`
- src: `c.j.s.pojo.Student`
- src: `c.j.s.mybatis.mapper.StudentMapper`
- src: `c.j.s.mybatis.StudentService/StudentServiceImpl`
- src: `c.j.s.mybatis.StudentController`
- tst: `c.j.s.mybatis.StudentMapperTest`
- tst: `c.j.s.mybatis.StudentServiceTest`
- psm: `api/student/select-by-id`

# 4. 整合WebSocket

> 现在，很多网站为了实现推送技术，所用的技术都是Ajax轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。

**概念：** WebSocket是HTML5提供的一种在单个TCP连接上进行全双工通讯的通讯协议，B端和S端只需完成一次握手即可建立一条快速的，持久的双向数据通道，更节省服务器资源和带宽，且允许S端主动向B端推送数据：
- 添加依赖：`spring-boot-starter-websocket`
- 开发配置类：开发 `ServerEndpointExporter` 的 `<bean>`。
- 开发S端类：负责接收客户端的 `ws://` 请求：
    - `@ServerEndpoint()`：指定 `ws://` 请求地址，建议使用REST风格配合 `@PathParam` 获取请求参数。
    - `webSocketServerMap`：负责存储每个用户的 `WebSocketServer` 对象：
        - 建议使用 `ConcurrentHashMap` 类型保证线程安全
        - 必须使用 `static` 修饰，否则不同用户看到的 `webSocketServerMap` 将不是同一个，会报错。
    - `javax.websocket.Session`：负责和WebSocket服务进行长连接通话。
    - `@OnOpen` 修饰的方法会在用户连入WebSocket服务端时执行，且只执行一次：
        - `onOpen()` 的两个参数都是从客户端传递过来的。
        - 将客户端传递过来的 `session` 对象作用域上升，因为后面推送消息的时候还会用到这个对象。
        - 将客户端传递过来的用户ID，以及当前用户的 `WebSocketServer` 对象打包存入 `webSocketServerMap`。
        - 利用 `session` 向客户端的 `onmessage()` 事件中传递消息：
            - `getAsyncRemote().sendText()`：异步传递消息，推荐。
            - `getBasicRemote().sendText()`：同步传递消息。
    - `@OnClose` 修饰的方法会在用户退出连接/退出客户端或者重新登陆的时候执行：
        - `onOpen()` 的两个参数都是从客户端传递过来的。
        - 从 `webSocketServerMap` 中 `reomove()` 这个用户。
    - `@OnError` 修饰的方法会在整个过程中生效，连接或者通信发生错误时执行。
    - `@OnMessage` 修饰的方法可以接受客户端通过 `socket.send()` 方法传递过来的值。
    - `sendById()`：是自定义的方法，负责向指定ID的用户发送消息：
        - 通过ID找到这个用户私有的 `WebSocketServer`。
        - 通过 `WebSocketServer` 获取这个用户私有的 `session` 对象。
        - 发送消息。
    - `sendToAll()`：是自定义的方法，负责向所有通话中的用户发送消息：
        - 遍历 `webSocketServerMap`，得到通话中的所有用户的 `WebSocketServer`。
        - 通过 `WebSocketServer` 获取每个用户私有的 `session` 对象。
        - 循环向每一个客户端的 `onmessage()` 事件中发送消息。
- 开发动作类：
- 开发B端类：

总结：
- 浏览器通过JS向服务器发出建立 `WebSocket` 连接的请求。
- 连接建立以后，客户端和服务器端就可以通过TCP连接直接交换数据。
- 客户端通过 `send()` 方法来向服务器发送数据。
- 客户端通过 `onmessage` 事件来接收服务器返回的数据。


客户端
**概念：** 编写两个html页面模拟两个用户。
1. 判断浏览器是否支持 `WebSocket`，一般主流浏览器都是支持的。
2. 新建 `WebSocket` 对象。
3. 设计 `WebSocket` 声明周期事件：
    - `onopen()`：当连接到 `WebSocket` 服务时。
        - `send()`：方法可以向服务端发送消息，被 `@OnMessage` 修饰的方法接收。
    - `onmessage()`：当接收到 `WebSocket` 服务推送的消息时。
    - `onclose()`：当从 `WebSocket` 服务断开时。
    - `onerror()`：当发生错误时。

测试
1. 启动springboot项目（启动WebSocket服务）。
2. 访问：`./user-01.html`，登录用户用户01，查看用户01的浏览器控制台信息。
3. 访问：`./user-02.html`，登录用户用户02，查看用户01的浏览器控制台信息。
4. 访问：`./websocket/send-to-user01.action?msg=hi user01`，向用户01发送消息，查看用户01的浏览器控制台信息。
5. 访问：`./websocket/send-to-user02.action?msg=hi user02`，向用户02发送消息，查看用户02的浏览器控制台信息。
6. 访问：`./websocket/send-to-all.action?msg=hi every body`，向所有用户发送消息，分别查看用户01和02的浏览器控制台信息。
7. 用户01点击 [退出通话]，查看用户01的浏览器控制台信息。
8. 再次访问：`./websocket/send-to-user01.action?msg=hi user01`，向用户01发送消息，查看用户01的浏览器控制台信息。
9. 用户01点击 [恢复通话]，查看用户01的浏览器控制台信息。
10. 再次访问：`./websocket/send-to-user01.action?msg=hi user01`，向用户01发送消息，查看用户01的浏览器控制台信息。
