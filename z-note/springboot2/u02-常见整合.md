# 1. 整合LogBack

**概念：** `spring-boot-starter` 依赖中包含了 `spring-boot-starter-logging` 依赖，即springboot默认使用logback作为日志框架，它是log4j的改进版，不能单独使用，推荐配合slf4j一起使用：
- springboot默认加载 `classpath:logback.xml` 或 `classpath:logback-spring.xml`：
- 自定义日志配置文件需要在主配文件中指定：`logging.config=classpath:console-log.xml`。
- 日志级别：TRACE < DEBUG < INFO < WARN < ERROR < ALL，不区分大小写。

**流程：** 将日志打印在控制台：
- 配置控制台追加器 `<appender name="STDOUT" class="c.q.l.c.ConsoleAppender>`：
    - `<encoder>` + `<pattern>/<charset>`：配置日志格式/字符集。
- 配置根记录器 `<root level="INFO">`：仅记录INFO及以上级别的启动日志和运行时日志：
    - `<appender-ref>` 使用 `ref` 属性关联某个追加器名，表示使用该追加器，可存在0或多个。
- 开发动作类并通过 `LoggerFactory.getLogger(getClass())` 获取当前类的 `Logger` 实例：
    - `logger.debug/info/warn/error("")`：记录一条DEBUG/INFO/WARN/ERROR级别的日志信息。

**流程：** 将日志输出到日志文件：
- 配置文件追加器 `<appender name="INFO" class="c.q.l.c.r.RollingFileAppender">`：
    - `<encoder>` + `<pattern>/<charset>`：配置日志格式/字符集。
    - `<file>`：指定日志文件路径，默认位置相对于所在项目，支持使用绝对路径。
    - `<append>`：设置是否追加日志，默认为true。
- 配置过滤器：`<filter class="c.q.l.c.f.LevelFilter">`：
    - `<level>ERROR</level>`：指定参考日志等级为ERROR。
    - `<onMatch>DENY</onMatch>`：ERROR级别日志阻止记录。
    - `<onMismatch>ACCEPT</onMismatch>`：除ERROR之外的级别日志允许记录。
- 配置滚动策略：`<rollingPolicy class="c.q.l.c.r.SizeAndTimeBasedRollingPolicy">`：
    - 策略：先将日志记录到日志文件中，如 `my.log`：
        - 日期变化时将昨天的日志文件重命名为 `my.日期.1.log`，今天的日志文件名仍用 `my.log`。
        - 日志文件超过拆分阈值时，将 `my.log` 拆为 `my.日期.1.log` 和 `my.日期.2.log`。
    - `<fileNamePattern>`：日志文件格式，建议使用 `log/warn.%d.%i.log`。
    - `<maxHistory>`：日志文件最长时效，单位根据 `<fileNamePattern>` 自动识别。
    - `<totalSizeCap>`：全部日志文件最大值，如 `10GB`，超出 `10GB` 立刻删除多余日志。
    - `<maxFileSize>`：每个日志文件拆分阈值，默认 `10MB`，文件大小超过此值时进行切分。
- 配置运行时记录器：`<logger name="c.j.app" level="WARN">`：仅记录指定包中WARN及以上级别日志：
    - `<appender-ref>` 使用 `ref` 属性关联某个追加器名，表示使用该追加器，可存在0或多个。
    - `<logger>` 针对指定包进行日志记录，可存在多个，但无法记录启动日志，启动日志需使用根记日志录器。
- 开发动作类：并通过 `LoggerFactory.getLogger(getClass())` 获取当前类的 `Logger` 实例：
    - `logger.debug/info/warn/error("")`：记录一条DEBUG/INFO/WARN/ERROR级别的日志信息。

> z-res/logback-pattern.md

**源码：** /springboot2/
- res: `classpath:console-log.xml`
- res: `classpath:file-log.xml`
- src: `c.j.s.controller.LogBackController`
- psm: `api/logback/test`

# 2. 整合Thymeleaf

**概念：** Thymeleaf是一种模版引擎，能处理HTML，XML，TEXT，JAVASCRIPT和CSS模板内容，springboot默认会顺序从 `/META-INF/resources`，`classpath:/resources/`，`classpath:/static/`，`classpath:/public/` 中寻找资源，有则直接返回，若都没有404：
- 添加依赖：`spring-boot-starter-thymeleaf`
- 主配添加：
    - `spring.web.resources.static-locations`：默认静态资源加载位置。
    - `spring.thymeleaf.enabled`：启用thymeleaf，默认true。
    - `spring.thymeleaf.cache`：启用thymeleaf缓存，默认true
    - `spring.thymeleaf.prefix`：配置thymeleaf响应路径前缀，默认classpath:/templates/。
    - `spring.thymeleaf.suffix`：配置thymeleaf响应路径后缀，默认.html。
    - `spring.thymeleaf.encoding`：配置thymeleaf编码，默认UTF-8。
- 动作类开发：响应路径自动补充主配中thymeleaf的前后缀。
- 页面开发：
    - 在 `<html>` 中添加thymeleaf的命名空间：`xmlns:th="http://www.thymeleaf.org"`。
    - 在HTML标签中使用` th:text="${msg }"` 可取出请求域中的值，该值支持 `+` 或 `|` 进行字符拼接。
- 友好页面：支持在 `classpath:/public/error` 下创建如 `4xx.html` 的HTTP状态反馈页面，仅浏览器生效。

**源码：** /springboot2/
- res: `classpath:application.properties`
- src: `c.j.s.controller.ThymeleafController`
- web: `classpath:templates/main.html`
- web: `classpath:public/error/4xx.html`
- web: `classpath:public/error/5xx.html`
- psm: `api/thymeleaf/test`

# 3. 整合MySQL

JDBC：原始java访问数据库，开发流程麻烦
apache dbutils框架：比上一步简单点，官网:https://commons.apache.org/proper/commons-dbutils/
jpa框架：jpa在复杂查询的时候性能不是很好
Hibernate框架：企业大都喜欢使用hibernate
Mybatis框架：互联网行业通常使用mybatis

2. 环境搭建

pom文件中，依赖导入
<!--spring-boot-starter-jdbc-->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-jdbc</artifactId>
</dependency>

<!--mybatis-spring-boot-starter-->
<dependency>
    <groupId>org.mybatis.spring.boot</groupId>
    <artifactId>mybatis-spring-boot-starter</artifactId>
    <version>2.0.0</version>
</dependency>

<!-- mysql驱动 -->
<dependency>
    <groupId>mysql</groupId>
    <artifactId>mysql-connector-java</artifactId>
    <scope>runtime</scope>
</dependency>


tips：spring-boot-starter-jdbc提供了事物功能，我们可以使用@Transaction来自动配置事物（该注解可以放在方法上，也可以放在类上）。
tips：因为我们pom.xml文件中的<parent>版本设置为了2.3.1，所以它所建议的mysql驱动版本为8.0.20。

配置文件application.xml文件
### 整合mybatis
# 引入mapper.xml文件
mybatis.mapper-locations=classpath:mybatis/mapper/*.xml
# 别名包扫描
mybatis.type-aliases-package=com.joe.boot.pojo
# 控制台打印sql语句，一般用于本地开发测试
mybatis.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl
# 数据源
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
spring.datasource.url=jdbc:mysql://127.0.0.1:3306/my?serverTimezone=UTC
spring.datasource.username=joe
spring.datasource.password=joe
# 连接池，默认com.zaxxer.hikari.HikariDataSource
spring.datasource.type=com.zaxxer.hikari.HikariDataSource


tips：8.0版本的mysql驱动连接串url的值后面要添加时区：serverTimezone=UTC
tips：时区如果要写成格林威治标准时间东八区，则改为"serverTimezone=GMT%2B8"，GMT+8，符号"+"要变为实体"%2B"。
tips：springboot默认使用com.zaxxer.hikari.HikariDataSource作为数据源连接池，如果想更换，可以设置spring.datasource.type=你的数据源类全名，如spring.datasource.type=com.alibaba.druid.pool.DruidDataSource
tips：加载配置，注入到sqlSessionFactory等都是springBoot帮我们完成的。

druid连接池依赖
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>druid</artifactId>
    <version>1.1.6</version>
</dependency>


2.1 模型层



Account.java
/**
 * @author JoeZhou
 */
@Data
public class Account implements Serializable {
   private Integer id;
   private String username;
   private String password;
}



3.5 简单XML配置方案

上面的纯注解方案，适合简单和快速开发，在简单逻辑下的微服务开发环境中无疑是最适合的，但如果你的SQL和业务逻辑都比较复杂，则仍旧可以使用之前mybatis的，带xml文件的配置方案(UserMapper.xml)，保持映射文件的老传统，接口层只需要定义空方法，系统会自动根据方法名在映射文件中找对应的Sql。

application.properties新增以下配置，为了让程序能找到我们的Mybatis基础配置文件和实体类映射文件的位置
# 引入mybatis-config.xml主配文件
mybatis.config-location=classpath:mybatis/mybatis-config.xml
# 引入mapper.xml文件
mybatis.mapper-locations=classpath:mybatis/mapper/*.xml


tips：在mybatis-config.xml可以配置别名等一些配置。
tips：UserMapper.xml文件专心配置SQL。
tips：其余参考mybatis开发。

2.2 数据层

配置：resources/mybatis/mapper/AccountMapper.xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">

<mapper namespace="com.joe.mapper.AccountMapper">

    <sql id="*">
        `id`, `username`, `password`
    </sql>

    <select id="login" resultType="Account">
        SELECT <include refid="*"/> FROM `account`
        <where>
            <choose>
                <when test="username != null and password != null ">
                    and `username` = #{username} and `password` = #{password}
                </when>
                <otherwise>
                    and 1 = 2
                </otherwise>
            </choose>
        </where>
    </select>

</mapper>



tips：当数据库字段名与实体类对应的属性名不一致时，可以使用@Results映射来将其对应起来，一致时可以省写@Results。
tips：AccountMapper.java文件上需要加@Mapper注解才能被管理，这里没有添加是因为，我们要在后面使用包扫描的方式来统一扫描。
tips：MyBatis中使用@Results注解来映射查询结果集到实体类属性，@Results中的每一个@Result对应一个字段。
tips：Mybatis常用的动态sql的注解写法，其实和xml是几乎完全一致的，但是在注解中使用动态sql时，我们需要为sql语句的两端加上<script></script>标签，这时候mybatis才会解析里面的标签，<script>标签的中间内容和xml版本一致。

当上面这段@Results代码需要在多个方法用到时，为了提高代码复用性，我们可以为这个@Results注解设置id，然后使用@ResultMap注解来复用这段代码。
@Results(id="loginResult", value={
    @Result(...),
    @Result(...)
    ...
})


当其他地方仍想使用这个@Results映射的时候，可以直接添加如下注解
@ResultMap(value="loginResult")


源码：AccountMapper.java
package com.joe.mapper;

import com.joe.pojo.Account;
import org.springframework.stereotype.Repository;

/**
 * @author JoeZhou
 */
@Repository
public interface AccountMapper {

    /**
     * 登录方法
     *
     * @param username 账号
     * @param password 密码
     * @return 返回登录成功的账号信息
     */
    Account login(String username, String password);
}


2.3 业务层

源码：AccountService.java
/**
 * @author JoeZhou
 */
public interface AccountService {

    /**
     * 登录方法
     *
     * @param username 账号
     * @param password 密码
     * @return 返回登录成功的账号信息
     */
    boolean login(String username, String password);
}


源码：AccountServiceImpl.java
/**
 * @author JoeZhou
 */
@Service
public class AccountServiceImpl implements AccountService {

    private AccountMapper accountMapper;

    @Autowired
    public AccountServiceImpl(AccountMapper accountMapper) {
        this.accountMapper = accountMapper;
    }

    @Override
    public boolean login(String username, String password) {
        Account account = accountMapper.login(username, password);
        return account != null;
    }
}



tips：@Transactional是jdbc包提供的事务管理注解，也可以将其放置在整个UserService类上，来对这个类中的所有方法使用事务。

2.4 控制层

AccountController.java
/**
 * @author JoeZhou
 */
@RestController
@RequestMapping("account")
public class AccountController {

    private AccountService accountService;

    @Autowired
    public AccountController(AccountService accountService) {
        this.accountService = accountService;
    }

    @RequestMapping("login.action")
    public boolean login(String username, String password) {
        return accountService.login(username, password);
    }
}


2.5 入口类

入口类需要添加@MapperScan来包扫描所有的Mapper接口，如果不想设置这项，也可以在每一个Mapper接口上添加@Mapper注解，两种方式二选其一。

package com.joe.app;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

/**
 * @author JoeZhou
 */
@SpringBootApplication
@MapperScan("com.joe.mapper")
public class App {
    public static void main(String[] args) {
        SpringApplication.run(App.class, args);
    }
}


测试
http://127.0.0.1:8080/my_springboot/account/login?username=admin&password=123



4. 发布到独立的tomcat中运行

在开发阶段我们推荐使用内嵌的tomcat进行开发，因为这样会方便很多，但是到生成环境，我希望在独立的tomcat容器中运行，因为我们需要对tomcat做额外的优化，这时我们需要将工程打包成war包发进行发布。
 
在pom.xml中添加如下依赖，替换之前的tomcat依赖
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-tomcat</artifactId>
    <scope>provided</scope>
</dependency>


tips：设置为provided是在打包时会将该包排除，因为要放到独立的tomcat中运行，是不需要的。

入口类继承SpringBootServletInitializer，然后重写configure，将入口类设置进去
@SpringBootApplication
public class HelloWorldApplication extends SpringBootServletInitializer{
	@Override
	protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) {
		return builder.sources(HelloWorldApplication.class);
	} 
}


项目右键run as：maven clean，清除之前打过的war包；
项目右键run as：maven install，将项目打成war包；
在项目的target文件夹下，你可以看到打成的war包；
将war包复制粘贴出来，重命名为项目名（建议，结合你项目代码中所用到的项目名）；
将war包放到tomcat安装目录下的webapps文件夹中；
启动tomcat；
浏览器访问：http://127.0.0.1:端口号/项目名/首页html；

